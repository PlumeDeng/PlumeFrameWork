/** Declaration file generated by dts-gen */

export const REVISION: string;

// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button
export enum MOUSE {
	LEFT,
	MIDDLE,
	RIGHT,
	ROTATE,
	DOLLY,
	PAN,
}

export enum TOUCH {
	ROTATE,
	PAN,
	DOLLY_PAN,
	DOLLY_ROTATE,
}

// GL STATE CONSTANTS
export enum CullFace {}
export const CullFaceNone: CullFace;
export const CullFaceBack: CullFace;
export const CullFaceFront: CullFace;
export const CullFaceFrontBack: CullFace;

export enum FrontFaceDirection {}
export const FrontFaceDirectionCW: FrontFaceDirection;
export const FrontFaceDirectionCCW: FrontFaceDirection;

// Shadowing Type
export enum ShadowMapType {}
export const BasicShadowMap: ShadowMapType;
export const PCFShadowMap: ShadowMapType;
export const PCFSoftShadowMap: ShadowMapType;
export const VSMShadowMap: ShadowMapType;

// MATERIAL CONSTANTS

// side
export enum Side {}
export const FrontSide: Side;
export const BackSide: Side;
export const DoubleSide: Side;

// shading
export enum Shading {}
export const FlatShading: Shading;
export const SmoothShading: Shading;

// blending modes
export enum Blending {}
export const NoBlending: Blending;
export const NormalBlending: Blending;
export const AdditiveBlending: Blending;
export const SubtractiveBlending: Blending;
export const MultiplyBlending: Blending;
export const CustomBlending: Blending;

// custom blending equations
// (numbers start from 100 not to clash with other
// mappings to OpenGL constants defined in Texture.js)
export enum BlendingEquation {}
export const AddEquation: BlendingEquation;
export const SubtractEquation: BlendingEquation;
export const ReverseSubtractEquation: BlendingEquation;
export const MinEquation: BlendingEquation;
export const MaxEquation: BlendingEquation;

// custom blending destination factors
export enum BlendingDstFactor {}
export const ZeroFactor: BlendingDstFactor;
export const OneFactor: BlendingDstFactor;
export const SrcColorFactor: BlendingDstFactor;
export const OneMinusSrcColorFactor: BlendingDstFactor;
export const SrcAlphaFactor: BlendingDstFactor;
export const OneMinusSrcAlphaFactor: BlendingDstFactor;
export const DstAlphaFactor: BlendingDstFactor;
export const OneMinusDstAlphaFactor: BlendingDstFactor;
export const DstColorFactor: BlendingDstFactor;
export const OneMinusDstColorFactor: BlendingDstFactor;

// custom blending src factors
export enum BlendingSrcFactor {}
export const SrcAlphaSaturateFactor: BlendingSrcFactor;

// depth modes
export enum DepthModes {}
export const NeverDepth: DepthModes;
export const AlwaysDepth: DepthModes;
export const LessDepth: DepthModes;
export const LessEqualDepth: DepthModes;
export const EqualDepth: DepthModes;
export const GreaterEqualDepth: DepthModes;
export const GreaterDepth: DepthModes;
export const NotEqualDepth: DepthModes;

// TEXTURE CONSTANTS
// Operations
export enum Combine {}
export const MultiplyOperation: Combine;
export const MixOperation: Combine;
export const AddOperation: Combine;

// Tone Mapping modes
export enum ToneMapping {}
export const NoToneMapping: ToneMapping;
export const LinearToneMapping: ToneMapping;
export const ReinhardToneMapping: ToneMapping;
export const Uncharted2ToneMapping: ToneMapping;
export const CineonToneMapping: ToneMapping;
export const ACESFilmicToneMapping: ToneMapping;

// Mapping modes
export enum Mapping {}
export const UVMapping: Mapping;
export const CubeReflectionMapping: Mapping;
export const CubeRefractionMapping: Mapping;
export const EquirectangularReflectionMapping: Mapping;
export const EquirectangularRefractionMapping: Mapping;
export const SphericalReflectionMapping: Mapping;
export const CubeUVReflectionMapping: Mapping;
export const CubeUVRefractionMapping: Mapping;

// Wrapping modes
export enum Wrapping {}
export const RepeatWrapping: Wrapping;
export const ClampToEdgeWrapping: Wrapping;
export const MirroredRepeatWrapping: Wrapping;

// Filters
export enum TextureFilter {}
export const NearestFilter: TextureFilter;
export const NearestMipmapNearestFilter: TextureFilter;
export const NearestMipMapNearestFilter: TextureFilter;
export const NearestMipmapLinearFilter: TextureFilter;
export const NearestMipMapLinearFilter: TextureFilter;
export const LinearFilter: TextureFilter;
export const LinearMipmapNearestFilter: TextureFilter;
export const LinearMipMapNearestFilter: TextureFilter;
export const LinearMipmapLinearFilter: TextureFilter;
export const LinearMipMapLinearFilter: TextureFilter;

// Data types
export enum TextureDataType {}
export const UnsignedByteType: TextureDataType;
export const ByteType: TextureDataType;
export const ShortType: TextureDataType;
export const UnsignedShortType: TextureDataType;
export const IntType: TextureDataType;
export const UnsignedIntType: TextureDataType;
export const FloatType: TextureDataType;
export const HalfFloatType: TextureDataType;
export const UnsignedShort4444Type: TextureDataType;
export const UnsignedShort5551Type: TextureDataType;
export const UnsignedShort565Type: TextureDataType;
export const UnsignedInt248Type: TextureDataType;

// Pixel formats
export enum PixelFormat {}
export const AlphaFormat: PixelFormat;
export const RGBFormat: PixelFormat;
export const RGBAFormat: PixelFormat;
export const LuminanceFormat: PixelFormat;
export const LuminanceAlphaFormat: PixelFormat;
export const RGBEFormat: PixelFormat;
export const DepthFormat: PixelFormat;
export const DepthStencilFormat: PixelFormat;
export const RedFormat: PixelFormat;
export const RedIntegerFormat: PixelFormat;
export const RGFormat: PixelFormat;
export const RGIntegerFormat: PixelFormat;
export const RGBIntegerFormat: PixelFormat;
export const RGBAIntegerFormat: PixelFormat;

// Internal Pixel Formats
export type PixelFormatGPU =
	'ALPHA'
	| 'RGB'
	| 'RGBA'
	| 'LUMINANCE'
	| 'LUMINANCE_ALPHA'
	| 'RED_INTEGER'
	| 'R8'
	| 'R8_SNORM'
	| 'R8I'
	| 'R8UI'
	| 'R16I'
	| 'R16UI'
	| 'R16F'
	| 'R32I'
	| 'R32UI'
	| 'R32F'
	| 'RG8'
	| 'RG8_SNORM'
	| 'RG8I'
	| 'RG8UI'
	| 'RG16I'
	| 'RG16UI'
	| 'RG16F'
	| 'RG32I'
	| 'RG32UI'
	| 'RG32F'
	| 'RGB565'
	| 'RGB8'
	| 'RGB8_SNORM'
	| 'RGB8I'
	| 'RGB8UI'
	| 'RGB16I'
	| 'RGB16UI'
	| 'RGB16F'
	| 'RGB32I'
	| 'RGB32UI'
	| 'RGB32F'
	| 'RGB9_E5'
	| 'SRGB8'
	| 'R11F_G11F_B10F'
	| 'RGBA4'
	| 'RGBA8'
	| 'RGBA8_SNORM'
	| 'RGBA8I'
	| 'RGBA8UI'
	| 'RGBA16I'
	| 'RGBA16UI'
	| 'RGBA16F'
	| 'RGBA32I'
	| 'RGBA32UI'
	| 'RGBA32F'
	| 'RGB5_A1'
	| 'RGB10_A2'
	| 'RGB10_A2UI'
	| 'SRGB8_ALPHA8'
	| 'DEPTH_COMPONENT16'
	| 'DEPTH_COMPONENT24'
	| 'DEPTH_COMPONENT32F'
	| 'DEPTH24_STENCIL8'
	| 'DEPTH32F_STENCIL8';

// Compressed texture formats
// DDS / ST3C Compressed texture formats
export enum CompressedPixelFormat {}
export const RGB_S3TC_DXT1_Format: CompressedPixelFormat;
export const RGBA_S3TC_DXT1_Format: CompressedPixelFormat;
export const RGBA_S3TC_DXT3_Format: CompressedPixelFormat;
export const RGBA_S3TC_DXT5_Format: CompressedPixelFormat;

// PVRTC compressed './texture formats
export const RGB_PVRTC_4BPPV1_Format: CompressedPixelFormat;
export const RGB_PVRTC_2BPPV1_Format: CompressedPixelFormat;
export const RGBA_PVRTC_4BPPV1_Format: CompressedPixelFormat;
export const RGBA_PVRTC_2BPPV1_Format: CompressedPixelFormat;

// ETC compressed texture formats
export const RGB_ETC1_Format: CompressedPixelFormat;
export const RGB_ETC2_Format: CompressedPixelFormat;
export const RGBA_ETC2_EAC_Format: CompressedPixelFormat;

// ASTC compressed texture formats
export const RGBA_ASTC_4x4_Format: CompressedPixelFormat;
export const RGBA_ASTC_5x4_Format: CompressedPixelFormat;
export const RGBA_ASTC_5x5_Format: CompressedPixelFormat;
export const RGBA_ASTC_6x5_Format: CompressedPixelFormat;
export const RGBA_ASTC_6x6_Format: CompressedPixelFormat;
export const RGBA_ASTC_8x5_Format: CompressedPixelFormat;
export const RGBA_ASTC_8x6_Format: CompressedPixelFormat;
export const RGBA_ASTC_8x8_Format: CompressedPixelFormat;
export const RGBA_ASTC_10x5_Format: CompressedPixelFormat;
export const RGBA_ASTC_10x6_Format: CompressedPixelFormat;
export const RGBA_ASTC_10x8_Format: CompressedPixelFormat;
export const RGBA_ASTC_10x10_Format: CompressedPixelFormat;
export const RGBA_ASTC_12x10_Format: CompressedPixelFormat;
export const RGBA_ASTC_12x12_Format: CompressedPixelFormat;
export const SRGB8_ALPHA8_ASTC_4x4_Format: CompressedPixelFormat;
export const SRGB8_ALPHA8_ASTC_5x4_Format: CompressedPixelFormat;
export const SRGB8_ALPHA8_ASTC_5x5_Format: CompressedPixelFormat;
export const SRGB8_ALPHA8_ASTC_6x5_Format: CompressedPixelFormat;
export const SRGB8_ALPHA8_ASTC_6x6_Format: CompressedPixelFormat;
export const SRGB8_ALPHA8_ASTC_8x5_Format: CompressedPixelFormat;
export const SRGB8_ALPHA8_ASTC_8x6_Format: CompressedPixelFormat;
export const SRGB8_ALPHA8_ASTC_8x8_Format: CompressedPixelFormat;
export const SRGB8_ALPHA8_ASTC_10x5_Format: CompressedPixelFormat;
export const SRGB8_ALPHA8_ASTC_10x6_Format: CompressedPixelFormat;
export const SRGB8_ALPHA8_ASTC_10x8_Format: CompressedPixelFormat;
export const SRGB8_ALPHA8_ASTC_10x10_Format: CompressedPixelFormat;
export const SRGB8_ALPHA8_ASTC_12x10_Format: CompressedPixelFormat;
export const SRGB8_ALPHA8_ASTC_12x12_Format: CompressedPixelFormat;

// BPTC compressed texture formats
export const RGBA_BPTC_Format: CompressedPixelFormat;

// Loop styles for AnimationAction
export enum AnimationActionLoopStyles {}
export const LoopOnce: AnimationActionLoopStyles;
export const LoopRepeat: AnimationActionLoopStyles;
export const LoopPingPong: AnimationActionLoopStyles;

// Interpolation
export enum InterpolationModes {}
export const InterpolateDiscrete: InterpolationModes;
export const InterpolateLinear: InterpolationModes;
export const InterpolateSmooth: InterpolationModes;

// Interpolant ending modes
export enum InterpolationEndingModes {}
export const ZeroCurvatureEnding: InterpolationEndingModes;
export const ZeroSlopeEnding: InterpolationEndingModes;
export const WrapAroundEnding: InterpolationEndingModes;

// Animation blending modes
export enum AnimationBlendMode { }
export const NormalAnimationBlendMode: AnimationBlendMode;
export const AdditiveAnimationBlendMode: AnimationBlendMode;

// Triangle Draw modes
export enum TrianglesDrawModes {}
export const TrianglesDrawMode: TrianglesDrawModes;
export const TriangleStripDrawMode: TrianglesDrawModes;
export const TriangleFanDrawMode: TrianglesDrawModes;

// Texture Encodings
export enum TextureEncoding {}
export const LinearEncoding: TextureEncoding;
export const sRGBEncoding: TextureEncoding;
export const GammaEncoding: TextureEncoding;
export const RGBEEncoding: TextureEncoding;
export const LogLuvEncoding: TextureEncoding;
export const RGBM7Encoding: TextureEncoding;
export const RGBM16Encoding: TextureEncoding;
export const RGBDEncoding: TextureEncoding;

// Depth packing strategies
export enum DepthPackingStrategies {}
export const BasicDepthPacking: DepthPackingStrategies;
export const RGBADepthPacking: DepthPackingStrategies;

// Normal Map types
export enum NormalMapTypes {}
export const TangentSpaceNormalMap: NormalMapTypes;
export const ObjectSpaceNormalMap: NormalMapTypes;

// Stencil Op types
export enum StencilOp {}
export const ZeroStencilOp: StencilOp;
export const KeepStencilOp: StencilOp;
export const ReplaceStencilOp: StencilOp;
export const IncrementStencilOp: StencilOp;
export const DecrementStencilOp: StencilOp;
export const IncrementWrapStencilOp: StencilOp;
export const DecrementWrapStencilOp: StencilOp;
export const InvertStencilOp: StencilOp;

// Stencil Func types
export enum StencilFunc {}
export const NeverStencilFunc: StencilFunc;
export const LessStencilFunc: StencilFunc;
export const EqualStencilFunc: StencilFunc;
export const LessEqualStencilFunc: StencilFunc;
export const GreaterStencilFunc: StencilFunc;
export const NotEqualStencilFunc: StencilFunc;
export const GreaterEqualStencilFunc: StencilFunc;
export const AlwaysStencilFunc: StencilFunc;

// usage types
export enum Usage {}
export const StaticDrawUsage: Usage;
export const DynamicDrawUsage: Usage;
export const StreamDrawUsage: Usage;
export const StaticReadUsage: Usage;
export const DynamicReadUsage: Usage;
export const StreamReadUsage: Usage;
export const StaticCopyUsage: Usage;
export const DynamicCopyUsage: Usage;
export const StreamCopyUsage: Usage;

export class AmbientLight extends Light{
    /**
	 * This creates a Ambientlight with a color.
	 * @param color Numeric value of the RGB component of the color or a Color instance.
	 */
	constructor( color?: Color | string | number, intensity?: number );

	castShadow: boolean;
	readonly isAmbientLight: true;
}

export class AmbientLightProbe extends LightProbe{
    constructor( color?: Color | string | number, intensity?: number );

	readonly isAmbientLightProbe: true;

}

export class AnimationClip {
    constructor(name: any, duration: any, tracks: any, blendMode: any);

    clone(): any;

    optimize(): any;

    resetDuration(): any;

    trim(): any;

    validate(): any;

    static CreateClipsFromMorphTargetSequences(morphTargets: any, fps: any, noLoop: any): any;

    static CreateFromMorphTargetSequence(name: any, morphTargetSequence: any, fps: any, noLoop: any): any;

    static findByName(objectOrClipArray: any, name: any): any;

    static parse(json: any): any;

    static parseAnimation(animation: any, bones: any): any;

    static toJSON(clip: any): any;

}

export class AnimationLoader {
    constructor(manager: any);

    load(url: any, onLoad: any, onProgress: any, onError: any): void;

    parse(json: any): any;

}

export class AnimationMixer {
    constructor(root: any);

    clipAction(clip: any, optionalRoot: any, blendMode: any): any;

    existingAction(clip: any, optionalRoot: any): any;

    getRoot(): any;

    setTime(timeInSeconds: any): any;

    stopAllAction(): any;

    uncacheAction(clip: any, optionalRoot: any): void;

    uncacheClip(clip: any): void;

    uncacheRoot(root: any): void;

    update(deltaTime: any): any;

}

export class AnimationObjectGroup {
    constructor(...args: any[]);

    add(...args: any[]): void;

    remove(...args: any[]): void;

    subscribe_(path: any, parsedPath: any): any;

    uncache(...args: any[]): void;

    unsubscribe_(path: any): void;

}

export class ArcCurve {
    constructor(aX: any, aY: any, aRadius: any, aStartAngle: any, aEndAngle: any, aClockwise: any);

}

export class ArrayCamera {
    constructor(array: any);

}

export class ArrowHelper {
    constructor(dir: any, origin: any, length: any, color: any, headLength: any, headWidth: any);

    clone(): any;

    copy(source: any): any;

    setColor(color: any): void;

    setDirection(dir: any): void;

    setLength(length: any, headLength: any, headWidth: any): void;

}

export class Audio {
    constructor(listener: any);

    connect(): any;

    disconnect(): any;

    getDetune(): any;

    getFilter(): any;

    getFilters(): any;

    getLoop(): any;

    getOutput(): any;

    getPlaybackRate(): any;

    getVolume(): any;

    load(file: any): any;

    onEnded(): void;

    pause(): any;

    play(delay: any): any;

    setBuffer(audioBuffer: any): any;

    setDetune(value: any): any;

    setFilter(filter: any): any;

    setFilters(value: any): any;

    setLoop(value: any): any;

    setLoopEnd(value: any): any;

    setLoopStart(value: any): any;

    setMediaElementSource(mediaElement: any): any;

    setMediaStreamSource(mediaStream: any): any;

    setNodeSource(audioNode: any): any;

    setPlaybackRate(value: any): any;

    setVolume(value: any): any;

    stop(): any;

}

export class AudioAnalyser {
    constructor(audio: any, fftSize: any);

    getAverageFrequency(): any;

    getData(): any;

    getFrequencyData(): any;

}

export class AudioListener {
    constructor();

    getFilter(): any;

    getInput(): any;

    getMasterVolume(): any;

    removeFilter(): any;

    setFilter(value: any): any;

    setMasterVolume(value: any): any;

    updateMatrixWorld(force: any): void;

}

export class AudioLoader {
    constructor(manager: any);

    load(url: any, onLoad: any, onProgress: any, onError: any): void;

}

export class Bone {
    constructor();

}

export class BooleanKeyframeTrack {
    constructor(name: any, times: any, values: any);

    // Native method; no parameter or return type inference available
    ValueBufferType(p0: any): any;

}

export class Box2 {
    constructor(min: any, max: any);

    center(optionalTarget: any): any;

    clampPoint(point: any, target: any): any;

    clone(): any;

    containsBox(box: any): any;

    containsPoint(point: any): any;

    copy(box: any): any;

    distanceToPoint(point: any): any;

    empty(): any;

    equals(box: any): any;

    expandByPoint(point: any): any;

    expandByScalar(scalar: any): any;

    expandByVector(vector: any): any;

    getCenter(target: any): any;

    getParameter(point: any, target: any): any;

    getSize(target: any): any;

    intersect(box: any): any;

    intersectsBox(box: any): any;

    isEmpty(): any;

    isIntersectionBox(box: any): any;

    makeEmpty(): any;

    set(min: any, max: any): any;

    setFromCenterAndSize(center: any, size: any): any;

    setFromPoints(points: any): any;

    size(optionalTarget: any): any;

    translate(offset: any): any;

    union(box: any): any;

}

export class Box3 {
    constructor(min: any, max: any);

    applyMatrix4(matrix: any): any;

    center(optionalTarget: any): any;

    clampPoint(point: any, target: any): any;

    clone(): any;

    containsBox(box: any): any;

    containsPoint(point: any): any;

    copy(box: any): any;

    distanceToPoint(point: any): any;

    empty(): any;

    equals(box: any): any;

    expandByObject(object: any): any;

    expandByPoint(point: any): any;

    expandByScalar(scalar: any): any;

    expandByVector(vector: any): any;

    getBoundingSphere(target: any): any;

    getCenter(target: any): any;

    getParameter(point: any, target: any): any;

    getSize(target: any): any;

    intersect(box: any): any;

    intersectsBox(box: any): any;

    intersectsPlane(plane: any): any;

    intersectsSphere(sphere: any): any;

    intersectsTriangle(triangle: any): any;

    isEmpty(): any;

    isIntersectionBox(box: any): any;

    isIntersectionSphere(sphere: any): any;

    makeEmpty(): any;

    set(min: any, max: any): any;

    setFromArray(array: any): any;

    setFromBufferAttribute(attribute: any): any;

    setFromCenterAndSize(center: any, size: any): any;

    setFromObject(object: any): any;

    setFromPoints(points: any): any;

    size(optionalTarget: any): any;

    translate(offset: any): any;

    union(box: any): any;

}

export class Box3Helper {
    constructor(box: any, color: any);

    updateMatrixWorld(force: any): void;

}

export class BoxHelper {
    constructor(object: any, color: any);

    clone(): any;

    copy(source: any): any;

    setFromObject(object: any): any;

    update(object: any): void;

}

export class BufferAttribute {
    constructor(array: any, itemSize: any, normalized: any);

    applyMatrix3(m: any): any;

    applyMatrix4(m: any): any;

    applyNormalMatrix(m: any): any;

    clone(): any;

    copy(source: any): any;

    copyArray(array: any): any;

    copyAt(index1: any, attribute: any, index2: any): any;

    copyColorsArray(colors: any): any;

    copyIndicesArray(): void;

    copyVector2sArray(vectors: any): any;

    copyVector3sArray(vectors: any): any;

    copyVector4sArray(vectors: any): any;

    getW(index: any): any;

    getX(index: any): any;

    getY(index: any): any;

    getZ(index: any): any;

    onUpload(callback: any): any;

    onUploadCallback(): void;

    set(value: any, offset: any): any;

    setArray(): void;

    setDynamic(value: any): any;

    setUsage(value: any): any;

    setW(index: any, w: any): any;

    setX(index: any, x: any): any;

    setXY(index: any, x: any, y: any): any;

    setXYZ(index: any, x: any, y: any, z: any): any;

    setXYZW(index: any, x: any, y: any, z: any, w: any): any;

    setY(index: any, y: any): any;

    setZ(index: any, z: any): any;

    toJSON(): any;

    transformDirection(m: any): any;

}

export class BufferGeometry {
    constructor();

    addAttribute(name: any, attribute: any, ...args: any[]): any;

    addDrawCall(start: any, count: any, indexOffset: any): void;

    addGroup(start: any, count: any, materialIndex: any): void;

    addIndex(index: any): void;

    applyMatrix(matrix: any): any;

    applyMatrix4(matrix: any): any;

    center(): any;

    clearDrawCalls(): void;

    clearGroups(): void;

    clone(): any;

    computeBoundingBox(): void;

    computeBoundingSphere(): void;

    computeFaceNormals(): void;

    computeOffsets(): void;

    computeTangents(): void;

    computeVertexNormals(): void;

    copy(source: any): any;

    deleteAttribute(name: any): any;

    dispose(): void;

    fromDirectGeometry(geometry: any): any;

    fromGeometry(geometry: any): any;

    getAttribute(name: any): any;

    getIndex(): any;

    lookAt(vector: any): any;

    merge(geometry: any, offset: any): any;

    normalizeNormals(): void;

    removeAttribute(name: any): any;

    rotateX(angle: any): any;

    rotateY(angle: any): any;

    rotateZ(angle: any): any;

    scale(x: any, y: any, z: any): any;

    setAttribute(name: any, attribute: any): any;

    setDrawRange(start: any, count: any): void;

    setFromObject(object: any): any;

    setFromPoints(points: any): any;

    setIndex(index: any): void;

    toJSON(): any;

    toNonIndexed(): any;

    translate(x: any, y: any, z: any): any;

    updateFromObject(object: any): any;

}

export class BufferGeometryLoader {
    constructor(manager: any);

    load(url: any, onLoad: any, onProgress: any, onError: any): void;

    parse(json: any): any;

}

export class Camera extends Object3D {
    constructor();

    clone(): any;

    copy(source: any, recursive: any): any;

    getWorldDirection(target: any): any;

    updateMatrixWorld(force: any): void;

    updateWorldMatrix(updateParents: any, updateChildren: any): void;

}

export class CameraHelper {
    constructor(camera: any);

    update(): void;

}

export class CanvasTexture {
    constructor(canvas: any, mapping: any, wrapS: any, wrapT: any, magFilter: any, minFilter: any, format: any, type: any, anisotropy: any);

}

export class CatmullRomCurve3 {
    constructor(points: any, closed: any, curveType: any, tension: any);

    copy(source: any): any;

    fromJSON(json: any): any;

    getPoint(t: any, optionalTarget: any): any;

    toJSON(): any;

}

export class Clock {
    constructor(autoStart: any);

    getDelta(): any;

    getElapsedTime(): any;

    start(): void;

    stop(): void;

}

export interface HSL {
	h: number;
	s: number;
	l: number;
}

export class Color {
    constructor( color?: Color | string | number );
	constructor( r: number, g: number, b: number );

	readonly isColor: true;

	/**
	 * Red channel value between 0 and 1. Default is 1.
	 */
	r: number;

	/**
	 * Green channel value between 0 and 1. Default is 1.
	 */
	g: number;

	/**
	 * Blue channel value between 0 and 1. Default is 1.
	 */
	b: number;

	set( color: Color ): Color;
	set( color: number ): Color;
	set( color: string ): Color;
	setScalar( scalar: number ): Color;
	setHex( hex: number ): Color;

	/**
	 * Sets this color from RGB values.
	 * @param r Red channel value between 0 and 1.
	 * @param g Green channel value between 0 and 1.
	 * @param b Blue channel value between 0 and 1.
	 */
	setRGB( r: number, g: number, b: number ): Color;

	/**
	 * Sets this color from HSL values.
	 * Based on MochiKit implementation by Bob Ippolito.
	 *
	 * @param h Hue channel value between 0 and 1.
	 * @param s Saturation value channel between 0 and 1.
	 * @param l Value channel value between 0 and 1.
	 */
	setHSL( h: number, s: number, l: number ): Color;

	/**
	 * Sets this color from a CSS context style string.
	 * @param contextStyle Color in CSS context style format.
	 */
	setStyle( style: string ): Color;

	/**
	 * Sets this color from a color name.
	 * Faster than {@link Color#setStyle .setStyle()} method if you don't need the other CSS-style formats.
	 * @param style Color name in X11 format.
	 */
	setColorName( style: string ): Color;

	/**
	 * Clones this color.
	 */
	clone(): this;

	/**
	 * Copies given color.
	 * @param color Color to copy.
	 */
	copy( color: Color ): this;

	/**
	 * Copies given color making conversion from gamma to linear space.
	 * @param color Color to copy.
	 */
	copyGammaToLinear( color: Color, gammaFactor?: number ): Color;

	/**
	 * Copies given color making conversion from linear to gamma space.
	 * @param color Color to copy.
	 */
	copyLinearToGamma( color: Color, gammaFactor?: number ): Color;

	/**
	 * Converts this color from gamma to linear space.
	 */
	convertGammaToLinear( gammaFactor?: number ): Color;

	/**
	 * Converts this color from linear to gamma space.
	 */
	convertLinearToGamma( gammaFactor?: number ): Color;

	/**
	 * Copies given color making conversion from sRGB to linear space.
	 * @param color Color to copy.
	 */
	copySRGBToLinear( color: Color ): Color;

	/**
	 * Copies given color making conversion from linear to sRGB space.
	 * @param color Color to copy.
	 */
	copyLinearToSRGB( color: Color ): Color;

	/**
	 * Converts this color from sRGB to linear space.
	 */
	convertSRGBToLinear(): Color;

	/**
	 * Converts this color from linear to sRGB space.
	 */
	convertLinearToSRGB(): Color;

	/**
	 * Returns the hexadecimal value of this color.
	 */
	getHex(): number;

	/**
	 * Returns the string formated hexadecimal value of this color.
	 */
	getHexString(): string;

	getHSL( target: HSL ): HSL;

	/**
	 * Returns the value of this color in CSS context style.
	 * Example: rgb(r, g, b)
	 */
	getStyle(): string;

	offsetHSL( h: number, s: number, l: number ): this;

	add( color: Color ): this;
	addColors( color1: Color, color2: Color ): this;
	addScalar( s: number ): this;
	sub( color: Color ): this;
	multiply( color: Color ): this;
	multiplyScalar( s: number ): this;
	lerp( color: Color, alpha: number ): this;
	lerpHSL( color: Color, alpha: number ): this;
	equals( color: Color ): boolean;

	/**
	 * Sets this color's red, green and blue value from the provided array.
	 * @param array the source array.
	 * @param offset (optional) offset into the array. Default is 0.
	 */
	fromArray( array: number[], offset?: number ): this;

	/**
	 * Sets this color's red, green and blue value from the provided array-like.
	 * @param array the source array-like.
	 * @param offset (optional) offset into the array-like. Default is 0.
	 */
	fromArray( array: ArrayLike<number>, offset?: number ): this;

	/**
	 * Returns an array [red, green, blue], or copies red, green and blue into the provided array.
	 * @param array (optional) array to store the color to. If this is not provided, a new array will be created.
	 * @param offset (optional) optional offset into the array.
	 * @return The created or provided array.
	 */
	toArray( array?: number[], offset?: number ): number[];

	/**
	 * Copies red, green and blue into the provided array-like.
	 * @param array array-like to store the color to.
	 * @param offset (optional) optional offset into the array-like.
	 * @return The provided array-like.
	 */
	toArray( xyz: ArrayLike<number>, offset?: number ): ArrayLike<number>;

	/**
	 * List of X11 color names.
	 */
	static NAMES: Record<string, number>;
}

export class ColorKeyframeTrack {
    constructor(name: any, times: any, values: any, interpolation: any);

}

export class CompressedTexture {
    constructor(mipmaps: any, width: any, height: any, format: any, type: any, mapping: any, wrapS: any, wrapT: any, magFilter: any, minFilter: any, anisotropy: any, encoding: any);

}

export class CompressedTextureLoader {
    constructor(manager: any);

    load(url: any, onLoad: any, onProgress: any, onError: any): any;

}

export class CubeCamera {
    constructor(near: any, far: any, cubeResolution: any, options: any);

    updateCubeMap(renderer: any, scene: any): any;

}

export class CubeTexture {
    constructor(images: any, mapping: any, wrapS: any, wrapT: any, magFilter: any, minFilter: any, format: any, type: any, anisotropy: any, encoding: any);

}

export class CubeTextureLoader {
    constructor(manager: any);

    load(urls: any, onLoad: any, onProgress: any, onError: any): any;

}

export class CubicBezierCurve {
    constructor(v0: any, v1: any, v2: any, v3: any);

    copy(source: any): any;

    fromJSON(json: any): any;

    getPoint(t: any, optionalTarget: any): any;

    toJSON(): any;

}

export class CubicBezierCurve3 {
    constructor(v0: any, v1: any, v2: any, v3: any);

    copy(source: any): any;

    fromJSON(json: any): any;

    getPoint(t: any, optionalTarget: any): any;

    toJSON(): any;

}

export class CubicInterpolant {
    constructor(parameterPositions: any, sampleValues: any, sampleSize: any, resultBuffer: any);

    interpolate_(i1: any, t0: any, t: any, t1: any): any;

    intervalChanged_(i1: any, t0: any, t1: any): void;

}

export class Curve {
    constructor();

    clone(): any;

    computeFrenetFrames(segments: any, closed: any): any;

    copy(source: any): any;

    fromJSON(json: any): any;

    getLength(): any;

    getLengths(divisions: any): any;

    getPoint(): any;

    getPointAt(u: any, optionalTarget: any): any;

    getPoints(divisions: any): any;

    getSpacedPoints(divisions: any): any;

    getTangent(t: any, optionalTarget: any): any;

    getTangentAt(u: any, optionalTarget: any): any;

    getUtoTmapping(u: any, distance: any): any;

    toJSON(): any;

    updateArcLengths(): void;

    static create(construct: any, getPoint: any): any;

}

export class CurvePath {
    constructor();

    add(curve: any): void;

    closePath(): void;

    copy(source: any): any;

    createGeometry(points: any): any;

    createPointsGeometry(divisions: any): any;

    createSpacedPointsGeometry(divisions: any): any;

    fromJSON(json: any): any;

    getCurveLengths(): any;

    getLength(): any;

    getPoint(t: any): any;

    getPoints(divisions: any): any;

    getSpacedPoints(divisions: any): any;

    toJSON(): any;

    updateArcLengths(): void;

}

export class Cylindrical {
    constructor(radius: any, theta: any, y: any);

    clone(): any;

    copy(other: any): any;

    set(radius: any, theta: any, y: any): any;

    setFromCartesianCoords(x: any, y: any, z: any): any;

    setFromVector3(v: any): any;

}

export class DataTexture {
    constructor(data: any, width: any, height: any, format: any, type: any, mapping: any, wrapS: any, wrapT: any, magFilter: any, minFilter: any, anisotropy: any, encoding: any);

}

export class DataTexture2DArray {
    constructor(data: any, width: any, height: any, depth: any);

}

export class DataTexture3D {
    constructor(data: any, width: any, height: any, depth: any);

}

export class DataTextureLoader {
    constructor(manager: any);

    load(url: any, onLoad: any, onProgress: any, onError: any): any;

}

export class DepthTexture {
    constructor(width: any, height: any, type: any, mapping: any, wrapS: any, wrapT: any, magFilter: any, minFilter: any, anisotropy: any, format: any);

}

export class DirectionalLight extends Light {

	constructor( color?: Color | string | number, intensity?: number );

	/**
	 * Target used for shadow camera orientation.
	 */
	target: Object3D;

	/**
	 * Light's intensity.
	 * Default â€” 1.0.
	 */
	intensity: number;

	shadow: DirectionalLightShadow;
	readonly isDirectionalLight: true;

}

export class DirectionalLightHelper {
    constructor(light: any, size: any, color: any);

    dispose(): void;

    update(): void;

}

export class DirectionalLightShadow extends LightShadow {

	camera: OrthographicCamera;
	readonly isDirectionalLightShadow: true;

}

export class DiscreteInterpolant {
    constructor(parameterPositions: any, sampleValues: any, sampleSize: any, resultBuffer: any);

    interpolate_(i1: any): any;

}

export class EllipseCurve {
    constructor(aX: any, aY: any, xRadius: any, yRadius: any, aStartAngle: any, aEndAngle: any, aClockwise: any, aRotation: any);

    copy(source: any): any;

    fromJSON(json: any): any;

    getPoint(t: any, optionalTarget: any): any;

    toJSON(): any;

}

export class Euler {

	constructor( x?: number, y?: number, z?: number, order?: string );

	x: number;
	y: number;
	z: number;
	order: string;
	readonly isEuler: true;

	_onChangeCallback: Function;

	set( x: number, y: number, z: number, order?: string ): Euler;
	clone(): this;
	copy( euler: Euler ): this;
	setFromRotationMatrix( m: Matrix4, order?: string ): Euler;
	setFromQuaternion( q: Quaternion, order?: string ): Euler;
	setFromVector3( v: Vector3, order?: string ): Euler;
	reorder( newOrder: string ): Euler;
	equals( euler: Euler ): boolean;
	fromArray( xyzo: any[] ): Euler;
	toArray( array?: number[], offset?: number ): number[];
	toVector3( optionalResult?: Vector3 ): Vector3;
	_onChange( callback: Function ): this;

	static RotationOrders: string[];
	static DefaultOrder: string;

}

export class EventDispatcher {
    constructor();

    addEventListener(type: any, listener: any): void;

    dispatchEvent(event: any): void;

    hasEventListener(type: any, listener: any): any;

    removeEventListener(type: any, listener: any): void;

}

export class ExtrudeBufferGeometry {
    constructor(shapes: any, options: any);

    addShape(): void;

    addShapeList(): void;

    getArrays(): void;

    toJSON(): any;

}

export class ExtrudeGeometry {
    constructor(shapes: any, options: any);

    toJSON(): any;

}

export class Face3 {
    constructor(a: any, b: any, c: any, normal: any, color: any, materialIndex: any);

    clone(): any;

    copy(source: any): any;

}

export class FileLoader {
    constructor(manager: any);

    load(url: any, onLoad: any, onProgress: any, onError: any): any;

    setMimeType(value: any): any;

    setRequestHeader(value: any): any;

    setResponseType(value: any): any;

    setWithCredentials(value: any): any;

}

export interface IFog {
	name: string;
	color: Color;
	clone(): this;
	toJSON(): any;
}

/**
 * This class contains the parameters that define linear fog, i.e., that grows linearly denser with the distance.
 */
export class Fog implements IFog {

	constructor( hex: number, near?: number, far?: number );

	name: string;

	/**
	 * Fog color.
	 */
	color: Color;

	/**
	 * The minimum distance to start applying fog. Objects that are less than 'near' units from the active camera won't be affected by fog.
	 */
	near: number;

	/**
	 * The maximum distance at which fog stops being calculated and applied. Objects that are more than 'far' units away from the active camera won't be affected by fog.
	 * Default is 1000.
	 */
	far: number;

	readonly isFog: true;

	clone(): this;
	toJSON(): any;

}

export class FogExp2 implements IFog {

	constructor( hex: number | string, density?: number );

	name: string;
	color: Color;

	/**
	 * Defines how fast the fog will grow dense.
	 * Default is 0.00025.
	 */
	density: number;

	readonly isFogExp2: true;

	clone(): this;
	toJSON(): any;

}

export class Font {
    constructor(data: any);

    generateShapes(text: any, size: any): any;

}

export class FontLoader {
    constructor(manager: any);

    load(url: any, onLoad: any, onProgress: any, onError: any): void;

    parse(json: any): any;

}

export class Frustum {
    constructor(p0: any, p1: any, p2: any, p3: any, p4: any, p5: any);

    clone(): any;

    containsPoint(point: any): any;

    copy(frustum: any): any;

    intersectsBox(box: any): any;

    intersectsObject(object: any): any;

    intersectsSphere(sphere: any): any;

    intersectsSprite(sprite: any): any;

    set(p0: any, p1: any, p2: any, p3: any, p4: any, p5: any): any;

    setFromMatrix(m: any): any;

    setFromProjectionMatrix(m: any): any;

}

export class Geometry {
    constructor();

    applyMatrix(matrix: any): any;

    applyMatrix4(matrix: any): any;

    center(): any;

    clone(): any;

    computeBoundingBox(): void;

    computeBoundingSphere(): void;

    computeFaceNormals(): void;

    computeFlatVertexNormals(): void;

    computeLineDistances(): void;

    computeMorphNormals(): void;

    computeTangents(): void;

    computeVertexNormals(areaWeighted: any): void;

    copy(source: any): any;

    dispose(): void;

    fromBufferGeometry(geometry: any): any;

    lookAt(vector: any): any;

    merge(geometry: any, matrix: any, materialIndexOffset: any): void;

    mergeMesh(mesh: any): void;

    mergeVertices(): any;

    normalize(): any;

    rotateX(angle: any): any;

    rotateY(angle: any): any;

    rotateZ(angle: any): any;

    scale(x: any, y: any, z: any): any;

    setFromPoints(points: any): any;

    sortFacesByMaterialIndex(): any;

    toJSON(): any;

    translate(x: any, y: any, z: any): any;

}

export class PlaneBufferGeometry extends BufferGeometry {

	constructor(
		width?: number,
		height?: number,
		widthSegments?: number,
		heightSegments?: number
	);

	parameters: {
		width: number;
		height: number;
		widthSegments: number;
		heightSegments: number;
	};

}

export class PlaneGeometry extends Geometry {

	constructor(
		width?: number,
		height?: number,
		widthSegments?: number,
		heightSegments?: number
	);

	parameters: {
		width: number;
		height: number;
		widthSegments: number;
		heightSegments: number;
	};

}

export class GridHelper extends LineSegments {

	constructor(
		size: number,
		divisions: number,
		color1?: Color | number,
		color2?: Color | number
	);
	/**
	 * @deprecated Colors should be specified in the constructor.
	 */
	setColors( color1?: Color | number, color2?: Color | number ): void;

}

export class Group {
    constructor();

}

export class HemisphereLight extends Light {

	constructor(
		skyColor?: Color | string | number,
		groundColor?: Color | string | number,
		intensity?: number
	);

	skyColor: Color;
	groundColor: Color;
	intensity: number;
	readonly isHemisphereLight: true;

}

export class HemisphereLightHelper {
    constructor(light: any, size: any, color: any);

    dispose(): void;

    update(): void;

}

export class HemisphereLightProbe {
    constructor(skyColor: any, groundColor: any, intensity: any);

    copy(source: any): any;

    toJSON(meta: any): any;

}

export class ImageBitmapLoader {
    constructor(manager: any);

    load(url: any, onLoad: any, onProgress: any, onError: any): any;

    setOptions(options: any): any;

}

export class ImageLoader {
    constructor(manager: any);

    load(url: any, onLoad: any, onProgress: any, onError: any): any;

}

export class ImmediateRenderObject {
    constructor(material: any);

}

export class InstancedBufferAttribute {
    constructor(array: any, itemSize: any, normalized: any, meshPerAttribute: any);

    copy(source: any): any;

    toJSON(): any;

}

export class InstancedBufferGeometry {
    constructor();

    clone(): any;

    copy(source: any): any;

    toJSON(): any;

}

export class InstancedInterleavedBuffer {
    constructor(array: any, stride: any, meshPerAttribute: any);

    copy(source: any): any;

}

export class InstancedMesh {
    constructor(geometry: any, material: any, count: any);

    getMatrixAt(index: any, matrix: any): void;

    raycast(raycaster: any, intersects: any): void;

    setMatrixAt(index: any, matrix: any): void;

    updateMorphTargets(): void;

}

export class InterleavedBuffer {
    constructor(array: any, stride: any);

    clone(): any;

    copy(source: any): any;

    copyAt(index1: any, attribute: any, index2: any): any;

    onUpload(callback: any): any;

    onUploadCallback(): void;

    set(value: any, offset: any): any;

    setArray(): void;

    setDynamic(value: any): any;

    setUsage(value: any): any;

}

export class InterleavedBufferAttribute {
    constructor(interleavedBuffer: any, itemSize: any, offset: any, normalized: any);

    applyMatrix4(m: any): any;

    getW(index: any): any;

    getX(index: any): any;

    getY(index: any): any;

    getZ(index: any): any;

    setW(index: any, w: any): any;

    setX(index: any, x: any): any;

    setXY(index: any, x: any, y: any): any;

    setXYZ(index: any, x: any, y: any, z: any): any;

    setXYZW(index: any, x: any, y: any, z: any, w: any): any;

    setY(index: any, y: any): any;

    setZ(index: any, z: any): any;

}

export class Interpolant {
    constructor(parameterPositions: any, sampleValues: any, sampleSize: any, resultBuffer: any);

    afterEnd_(index: any): any;

    beforeStart_(index: any): any;

    copySampleValue_(index: any): any;

    evaluate(t: any): any;

    getSettings_(): any;

    interpolate_(): void;

    intervalChanged_(): void;

}

export class KeyframeTrack {
    constructor(name: any, times: any, values: any, interpolation: any);

    InterpolantFactoryMethodDiscrete(result: any): any;

    InterpolantFactoryMethodLinear(result: any): any;

    InterpolantFactoryMethodSmooth(result: any): any;

    // Native method; no parameter or return type inference available
    TimeBufferType(p0: any, p1: any, p2: any): any;

    // Native method; no parameter or return type inference available
    ValueBufferType(p0: any, p1: any, p2: any): any;

    clone(): any;

    getInterpolation(): any;

    getValueSize(): any;

    optimize(): any;

    scale(timeScale: any): any;

    setInterpolation(interpolation: any): any;

    shift(timeOffset: any): any;

    trim(startTime: any, endTime: any): any;

    validate(): any;

    static toJSON(track: any): any;

}

export class LOD {
    constructor();

    addLevel(object: any, distance: any): any;

    copy(source: any): any;

    getCurrentLevel(): any;

    getObjectForDistance(distance: any): any;

    raycast(raycaster: any, intersects: any): void;

    toJSON(meta: any): any;

    update(camera: any): void;

}

export class Layers {
    constructor();

    disable(channel: any): void;

    disableAll(): void;

    enable(channel: any): void;

    enableAll(): void;

    set(channel: any): void;

    test(layers: any): any;

    toggle(channel: any): void;

}


export class Light extends Object3D {

	constructor( hex?: number | string, intensity?: number );

	color: Color;
	intensity: number;
	readonly isLight: true;
	receiveShadow: boolean;
	shadow: LightShadow;
	/**
	 * @deprecated Use shadow.camera.fov instead.
	 */
	shadowCameraFov: any;
	/**
	 * @deprecated Use shadow.camera.left instead.
	 */
	shadowCameraLeft: any;
	/**
	 * @deprecated Use shadow.camera.right instead.
	 */
	shadowCameraRight: any;
	/**
	 * @deprecated Use shadow.camera.top instead.
	 */
	shadowCameraTop: any;
	/**
	 * @deprecated Use shadow.camera.bottom instead.
	 */
	shadowCameraBottom: any;
	/**
	 * @deprecated Use shadow.camera.near instead.
	 */
	shadowCameraNear: any;
	/**
	 * @deprecated Use shadow.camera.far instead.
	 */
	shadowCameraFar: any;
	/**
	 * @deprecated Use shadow.bias instead.
	 */
	shadowBias: any;
	/**
	 * @deprecated Use shadow.mapSize.width instead.
	 */
	shadowMapWidth: any;
	/**
	 * @deprecated Use shadow.mapSize.height instead.
	 */
	shadowMapHeight: any;

}

export class LightProbe {
    constructor(sh: any, intensity: any);

    copy(source: any): any;

    fromJSON(json: any): any;

    toJSON(meta: any): any;

}

export class LightShadow {
    constructor( camera: Camera );

	camera: Camera;
	bias: number;
	radius: number;
	mapSize: Vector2;
	map: RenderTarget;
	mapPass: RenderTarget;
	matrix: Matrix4;

	copy( source: LightShadow ): this;
	clone( recursive?: boolean ): this;
	toJSON(): any;
	getFrustum(): number;
	updateMatrices( light: Light, viewportIndex?: number ): void;
	getViewport( viewportIndex: number ): Vector4;
	getFrameExtents(): Vector2;
}

export class Line extends Object3D {

	constructor(
		geometry?: Geometry | BufferGeometry,
		material?: Material | Material[],
		mode?: number
	);

	geometry: Geometry | BufferGeometry;
	material: Material;

	type: 'Line' | 'LineLoop' | 'LineSegments';
	readonly isLine: true;

	computeLineDistances(): this;
	raycast( raycaster: Raycaster, intersects: Intersection[] ): void;

}

export class Line3 {
    constructor(start: any, end: any);

    applyMatrix4(matrix: any): any;

    at(t: any, target: any): any;

    center(optionalTarget: any): any;

    clone(): any;

    closestPointToPoint(point: any, clampToLine: any, target: any): any;

    closestPointToPointParameter(point: any, clampToLine: any): any;

    copy(line: any): any;

    delta(target: any): any;

    distance(): any;

    distanceSq(): any;

    equals(line: any): any;

    getCenter(target: any): any;

    set(start: any, end: any): any;

}

export class LineBasicMaterial {
    constructor(parameters: any);

    copy(source: any): any;

}

export class LineCurve {
    constructor(v1: any, v2: any);

    copy(source: any): any;

    fromJSON(json: any): any;

    getPoint(t: any, optionalTarget: any): any;

    getPointAt(u: any, optionalTarget: any): any;

    getTangent(t: any, optionalTarget: any): any;

    toJSON(): any;

}

export class LineCurve3 {
    constructor(v1: any, v2: any);

    copy(source: any): any;

    fromJSON(json: any): any;

    getPoint(t: any, optionalTarget: any): any;

    getPointAt(u: any, optionalTarget: any): any;

    toJSON(): any;

}

export class LineDashedMaterial {
    constructor(parameters: any);

    copy(source: any): any;

}

export class LineLoop {
    constructor(geometry: any, material: any);

}

export class LineSegments extends Line {

	constructor(
		geometry?: Geometry | BufferGeometry,
		material?: Material | Material[],
		mode?: number
	);

	type: 'LineSegments';
	readonly isLineSegments: true;

}

export class LinearInterpolant {
    constructor(parameterPositions: any, sampleValues: any, sampleSize: any, resultBuffer: any);

    interpolate_(i1: any, t0: any, t: any, t1: any): any;

}

export const DefaultLoadingManager: LoadingManager;

/**
 * Handles and keeps track of loaded and pending data.
 */
export class LoadingManager {

	constructor(
		onLoad?: () => void,
		onProgress?: ( url: string, loaded: number, total: number ) => void,
		onError?: ( url: string ) => void
	);

	/**
	 * Will be called when loading of an item starts.
	 * @param url The url of the item that started loading.
	 * @param loaded The number of items already loaded so far.
	 * @param total The total amount of items to be loaded.
	 */
	onStart?: ( url: string, loaded: number, total: number ) => void;

	/**
	 * Will be called when all items finish loading.
	 * The default is a function with empty body.
	 */
	onLoad: () => void;

	/**
	 * Will be called for each loaded item.
	 * The default is a function with empty body.
	 * @param url The url of the item just loaded.
	 * @param loaded The number of items already loaded so far.
	 * @param total The total amount of items to be loaded.
	 */
	onProgress: ( url: string, loaded: number, total: number ) => void;

	/**
	 * Will be called when item loading fails.
	 * The default is a function with empty body.
	 * @param url The url of the item that errored.
	 */
	onError: ( url: string ) => void;

	/**
	 * If provided, the callback will be passed each resource URL before a request is sent.
	 * The callback may return the original URL, or a new URL to override loading behavior.
	 * This behavior can be used to load assets from .ZIP files, drag-and-drop APIs, and Data URIs.
	 * @param callback URL modifier callback. Called with url argument, and must return resolvedURL.
	 */
	setURLModifier( callback?: ( url: string ) => string ): this;

	/**
	 * Given a URL, uses the URL modifier callback (if any) and returns a resolved URL.
	 * If no URL modifier is set, returns the original URL.
	 * @param url the url to load
	 */
	resolveURL( url: string ): string;

	itemStart( url: string ): void;
	itemEnd( url: string ): void;
	itemError( url: string ): void;

	// handlers

	addHandler( regex: RegExp, loader: Loader ): this;
	removeHandler( regex: RegExp ): this;
	getHandler( file: string ): Loader | null;

}

export class Loader {
    constructor( manager?: LoadingManager );

	crossOrigin: string;
	path: string;
	resourcePath: string;
	manager: LoadingManager;

	/*
	load(): void;
	parse(): void;
	*/

	loadAsync( url: string, onProgress?: ( event: ProgressEvent ) => void ): Promise<any>;

	setCrossOrigin( crossOrigin: string ): this;
	setPath( path: string ): this;
	setResourcePath( resourcePath: string ): this;

}

export let MaterialIdCount: number;

export interface MaterialParameters {
	alphaTest?: number;
	blendDst?: BlendingDstFactor;
	blendDstAlpha?: number;
	blendEquation?: BlendingEquation;
	blendEquationAlpha?: number;
	blending?: Blending;
	blendSrc?: BlendingSrcFactor | BlendingDstFactor;
	blendSrcAlpha?: number;
	clipIntersection?: boolean;
	clippingPlanes?: Plane[];
	clipShadows?: boolean;
	colorWrite?: boolean;
	defines?: any;
	depthFunc?: DepthModes;
	depthTest?: boolean;
	depthWrite?: boolean;
	fog?: boolean;
	name?: string;
	opacity?: number;
	polygonOffset?: boolean;
	polygonOffsetFactor?: number;
	polygonOffsetUnits?: number;
	precision?: 'highp' | 'mediump' | 'lowp' | null;
	premultipliedAlpha?: boolean;
	dithering?: boolean;
	flatShading?: boolean;
	side?: Side;
	shadowSide?: Side;
	toneMapped?: boolean;
	transparent?: boolean;
	vertexColors?: boolean;
	visible?: boolean;
	stencilWrite?: boolean;
	stencilFunc?: StencilFunc;
	stencilRef?: number;
	stencilMask?: number;
	stencilFail?: StencilOp;
	stencilZFail?: StencilOp;
	stencilZPass?: StencilOp;
}

/**
 * Materials describe the appearance of objects. They are defined in a (mostly) renderer-independent way, so you don't have to rewrite materials if you decide to use a different renderer.
 */
export class Material extends EventDispatcher {

	constructor();

	/**
	 * Sets the alpha value to be used when running an alpha test. Default is 0.
	 */
	alphaTest: number;

	/**
	 * Blending destination. It's one of the blending mode constants defined in Three.js. Default is {@link OneMinusSrcAlphaFactor}.
	 */
	blendDst: BlendingDstFactor;

	/**
	 * The tranparency of the .blendDst. Default is null.
	 */
	blendDstAlpha: number | null;

	/**
	 * Blending equation to use when applying blending. It's one of the constants defined in Three.js. Default is {@link AddEquation}.
	 */
	blendEquation: BlendingEquation;

	/**
	 * The tranparency of the .blendEquation. Default is null.
	 */
	blendEquationAlpha: number | null;

	/**
	 * Which blending to use when displaying objects with this material. Default is {@link NormalBlending}.
	 */
	blending: Blending;

	/**
	 * Blending source. It's one of the blending mode constants defined in Three.js. Default is {@link SrcAlphaFactor}.
	 */
	blendSrc: BlendingSrcFactor | BlendingDstFactor;

	/**
	 * The tranparency of the .blendSrc. Default is null.
	 */
	blendSrcAlpha: number | null;

	/**
	 * Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union. Default is false.
	 */
	clipIntersection: boolean;

	/**
	 * User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). See the WebGL / clipping /intersection example. Default is null.
	 */
	clippingPlanes: any;

	/**
	 * Defines whether to clip shadows according to the clipping planes specified on this material. Default is false.
	 */
	clipShadows: boolean;

	/**
	 * Whether to render the material's color. This can be used in conjunction with a mesh's .renderOrder property to create invisible objects that occlude other objects. Default is true.
	 */
	colorWrite: boolean;

	/**
	 * Custom defines to be injected into the shader. These are passed in form of an object literal, with key/value pairs. { MY_CUSTOM_DEFINE: '' , PI2: Math.PI * 2 }.
	 * The pairs are defined in both vertex and fragment shaders. Default is undefined.
	 */
	defines: any;

	/**
	 * Which depth function to use. Default is {@link LessEqualDepth}. See the depth mode constants for all possible values.
	 */
	depthFunc: DepthModes;

	/**
	 * Whether to have depth test enabled when rendering this material. Default is true.
	 */
	depthTest: boolean;

	/**
	 * Whether rendering this material has any effect on the depth buffer. Default is true.
	 * When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts.
	 */
	depthWrite: boolean;

	/**
	 * Whether the material is affected by fog. Default is true.
	 */
	fog: boolean;

	/**
	 * Unique number of this material instance.
	 */
	id: number;

	/**
   * Whether rendering this material has any effect on the stencil buffer. Default is *false*.
   */
	stencilWrite: boolean;

	/**
   * The stencil comparison function to use. Default is {@link AlwaysStencilFunc}. See stencil operation constants for all possible values.
   */
	stencilFunc: StencilFunc;

	/**
   * The value to use when performing stencil comparisons or stencil operations. Default is *0*.
   */
	stencilRef: number;

	/**
   * The bit mask to use when comparing against or writing to the stencil buffer. Default is *0xFF*.
   */
	stencilMask: number;

	/**
   * Which stencil operation to perform when the comparison function returns false. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.
   */
	stencilFail: StencilOp;

	/**
   * Which stencil operation to perform when the comparison function returns true but the depth test fails. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.
   */
	stencilZFail: StencilOp;

	/**
   * Which stencil operation to perform when the comparison function returns true and the depth test passes. Default is {@link KeepStencilOp}. See the stencil operation constants for all possible values.
   */
	stencilZPass: StencilOp;

	/**
	 * Used to check whether this or derived classes are materials. Default is true.
	 * You should not change this, as it used internally for optimisation.
	 */
	readonly isMaterial: true;

	/**
	 * Material name. Default is an empty string.
	 */
	name: string;

	/**
	 * Specifies that the material needs to be updated, WebGL wise. Set it to true if you made changes that need to be reflected in WebGL.
	 * This property is automatically set to true when instancing a new material.
	 */
	needsUpdate: boolean;

	/**
	 * Opacity. Default is 1.
	 */
	opacity: number;

	/**
	 * Whether to use polygon offset. Default is false. This corresponds to the POLYGON_OFFSET_FILL WebGL feature.
	 */
	polygonOffset: boolean;

	/**
	 * Sets the polygon offset factor. Default is 0.
	 */
	polygonOffsetFactor: number;

	/**
	 * Sets the polygon offset units. Default is 0.
	 */
	polygonOffsetUnits: number;

	/**
	 * Override the renderer's default precision for this material. Can be "highp", "mediump" or "lowp". Defaults is null.
	 */
	precision: 'highp' | 'mediump' | 'lowp' | null;

	/**
	 * Whether to premultiply the alpha (transparency) value. See WebGL / Materials / Transparency for an example of the difference. Default is false.
	 */
	premultipliedAlpha: boolean;

	/**
	 * Whether to apply dithering to the color to remove the appearance of banding. Default is false.
	 */
	dithering: boolean;

	/**
	 * Define whether the material is rendered with flat shading. Default is false.
	 */
	flatShading: boolean;

	/**
	 * Defines which of the face sides will be rendered - front, back or both.
	 * Default is THREE.FrontSide. Other options are THREE.BackSide and THREE.DoubleSide.
	 */
	side: Side;

	/**
	 * Defines which of the face sides will cast shadows. Default is *null*.
	 * If *null*, the value is opposite that of side, above.
	 */
	shadowSide: Side;

	/**
	 * Defines whether this material is tone mapped according to the renderer's toneMapping setting.
	 * Default is true.
	 */
	toneMapped: boolean;

	/**
	 * Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects.
	 * When set to true, the extent to which the material is transparent is controlled by setting it's .opacity property.
	 * Default is false.
	 */
	transparent: boolean;

	/**
	 * Value is the string 'Material'. This shouldn't be changed, and can be used to find all objects of this type in a scene.
	 */
	type: string;

	/**
	 * UUID of this material instance. This gets automatically assigned, so this shouldn't be edited.
	 */
	uuid: string;

	/**
	 * Defines whether vertex coloring is used. Default is false.
	 */
	vertexColors: boolean;

	/**
	 * Defines whether this material is visible. Default is true.
	 */
	visible: boolean;

	/**
	 * An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned.
	 */
	userData: any;

	/**
	 * This starts at 0 and counts how many times .needsUpdate is set to true.
	 */
	version: number;

	/**
	 * Return a new material with the same parameters as this material.
	 */
	clone(): this;

	/**
	 * Copy the parameters from the passed material into this material.
	 * @param material
	 */
	copy( material: Material ): this;

	/**
	 * This disposes the material. Textures of a material don't get disposed. These needs to be disposed by {@link Texture}.
	 */
	dispose(): void;

	/**
	 * An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials.
	 * @param shader Source code of the shader
	 * @param renderer WebGLRenderer Context that is initializing the material
	 */
	onBeforeCompile ( shader : Shader, renderer : WebGLRenderer ) : void;

	/**
	 * Sets the properties based on the values.
	 * @param values A container with parameters.
	 */
	setValues( values: MaterialParameters ): void;

	/**
	 * Convert the material to three.js JSON format.
	 * @param meta Object containing metadata such as textures or images for the material.
	 */
	toJSON( meta?: any ): any;

}

export interface Shader {
	uniforms: { [uniform: string]: IUniform };
	vertexShader: string;
	fragmentShader: string;
}

export interface IUniform {
	value: any;
}

export class MaterialLoader {
    constructor(manager: any);

    load(url: any, onLoad: any, onProgress: any, onError: any): void;

    parse(json: any): any;

    setTextures(value: any): any;

}

export class Matrix3 {
    constructor(...args: any[]);

    applyToBufferAttribute(attribute: any): any;

    applyToVector3Array(): void;

    clone(): any;

    copy(m: any): any;

    determinant(): any;

    equals(matrix: any): any;

    extractBasis(xAxis: any, yAxis: any, zAxis: any): any;

    flattenToArrayOffset(array: any, offset: any): any;

    fromArray(array: any, offset: any): any;

    getInverse(matrix: any, throwOnDegenerate: any): any;

    getNormalMatrix(matrix4: any): any;

    identity(): any;

    multiply(m: any): any;

    multiplyMatrices(a: any, b: any): any;

    multiplyScalar(s: any): any;

    multiplyVector3(vector: any): any;

    multiplyVector3Array(): void;

    premultiply(m: any): any;

    rotate(theta: any): any;

    scale(sx: any, sy: any): any;

    set(n11: any, n12: any, n13: any, n21: any, n22: any, n23: any, n31: any, n32: any, n33: any): any;

    setFromMatrix4(m: any): any;

    setUvTransform(tx: any, ty: any, sx: any, sy: any, rotation: any, cx: any, cy: any): void;

    toArray(array: any, offset: any): any;

    translate(tx: any, ty: any): any;

    transpose(): any;

    transposeIntoArray(r: any): any;

}

export class Matrix4 {
    constructor(...args: any[]);

    applyToBufferAttribute(attribute: any): any;

    applyToVector3Array(): void;

    clone(): any;

    compose(position: any, quaternion: any, scale: any): any;

    copy(m: any): any;

    copyPosition(m: any): any;

    crossVector(vector: any): any;

    decompose(position: any, quaternion: any, scale: any): any;

    determinant(): any;

    equals(matrix: any): any;

    extractBasis(xAxis: any, yAxis: any, zAxis: any): any;

    extractPosition(m: any): any;

    extractRotation(m: any): any;

    flattenToArrayOffset(array: any, offset: any): any;

    fromArray(array: any, offset: any): any;

    getInverse(m: any, throwOnDegenerate: any): any;

    getMaxScaleOnAxis(): any;

    getPosition(): any;

    identity(): any;

    lookAt(eye: any, target: any, up: any): any;

    makeBasis(xAxis: any, yAxis: any, zAxis: any): any;

    makeFrustum(left: any, right: any, bottom: any, top: any, near: any, far: any): any;

    makeOrthographic(left: any, right: any, top: any, bottom: any, near: any, far: any): any;

    makePerspective(left: any, right: any, top: any, bottom: any, near: any, far: any): any;

    makeRotationAxis(axis: any, angle: any): any;

    makeRotationFromEuler(euler: any): any;

    makeRotationFromQuaternion(q: any): any;

    makeRotationX(theta: any): any;

    makeRotationY(theta: any): any;

    makeRotationZ(theta: any): any;

    makeScale(x: any, y: any, z: any): any;

    makeShear(x: any, y: any, z: any): any;

    makeTranslation(x: any, y: any, z: any): any;

    multiply(m: any, n: any): any;

    multiplyMatrices(a: any, b: any): any;

    multiplyScalar(s: any): any;

    multiplyToArray(): void;

    multiplyVector3(vector: any): any;

    multiplyVector3Array(): void;

    multiplyVector4(vector: any): any;

    premultiply(m: any): any;

    rotateAxis(v: any): void;

    rotateByAxis(): void;

    rotateX(): void;

    rotateY(): void;

    rotateZ(): void;

    scale(v: any): any;

    set(n11: any, n12: any, n13: any, n14: any, n21: any, n22: any, n23: any, n24: any, n31: any, n32: any, n33: any, n34: any, n41: any, n42: any, n43: any, n44: any): any;

    setPosition(x: any, y: any, z: any): any;

    setRotationFromQuaternion(q: any): any;

    toArray(array: any, offset: any): any;

    translate(): void;

    transpose(): any;

}

export class Mesh extends Object3D {

	constructor(
		geometry?: Geometry | BufferGeometry,
		material?: Material | Material[]
	);

	geometry: Geometry | BufferGeometry;
	material: Material | Material[];
	morphTargetInfluences?: number[];
	morphTargetDictionary?: { [key: string]: number };
	readonly isMesh: true;
	type: string;

	updateMorphTargets(): void;
	raycast( raycaster: Raycaster, intersects: Intersection[] ): void;

}

export interface MeshBasicMaterialParameters extends MaterialParameters {
	color?: Color | string | number;
	opacity?: number;
	map?: Texture | null;
	aoMap?: Texture | null;
	aoMapIntensity?: number;
	specularMap?: Texture | null;
	alphaMap?: Texture | null;
	envMap?: Texture | null;
	combine?: Combine;
	reflectivity?: number;
	refractionRatio?: number;
	wireframe?: boolean;
	wireframeLinewidth?: number;
	wireframeLinecap?: string;
	wireframeLinejoin?: string;
	skinning?: boolean;
	morphTargets?: boolean;
}

export class MeshBasicMaterial extends Material {

	constructor( parameters?: MeshBasicMaterialParameters );

	color: Color;
	map: Texture | null;
	aoMap: Texture | null;
	aoMapIntensity: number;
	specularMap: Texture | null;
	alphaMap: Texture | null;
	envMap: Texture | null;
	combine: Combine;
	reflectivity: number;
	refractionRatio: number;
	wireframe: boolean;
	wireframeLinewidth: number;
	wireframeLinecap: string;
	wireframeLinejoin: string;
	skinning: boolean;
	morphTargets: boolean;

	setValues( parameters: MeshBasicMaterialParameters ): void;

}

export class MeshDepthMaterial {
    constructor(parameters: any);

    copy(source: any): any;

}

export class MeshDistanceMaterial {
    constructor(parameters: any);

    copy(source: any): any;

}

export interface MeshLambertMaterialParameters extends MaterialParameters {
	color?: Color | string | number;
	emissive?: Color | string | number;
	emissiveIntensity?: number;
	emissiveMap?: Texture | null;
	map?: Texture | null;
	lightMap?: Texture | null;
	lightMapIntensity?: number;
	aoMap?: Texture | null;
	aoMapIntensity?: number;
	specularMap?: Texture | null;
	alphaMap?: Texture | null;
	envMap?: Texture | null;
	combine?: Combine;
	reflectivity?: number;
	refractionRatio?: number;
	wireframe?: boolean;
	wireframeLinewidth?: number;
	wireframeLinecap?: string;
	wireframeLinejoin?: string;
	skinning?: boolean;
	morphTargets?: boolean;
	morphNormals?: boolean;
}

export class MeshLambertMaterial extends Material {

	constructor( parameters?: MeshLambertMaterialParameters );

	color: Color;
	emissive: Color;
	emissiveIntensity: number;
	emissiveMap: Texture | null;
	map: Texture | null;
	lightMap: Texture | null;
	lightMapIntensity: number;
	aoMap: Texture | null;
	aoMapIntensity: number;
	specularMap: Texture | null;
	alphaMap: Texture | null;
	envMap: Texture | null;
	combine: Combine;
	reflectivity: number;
	refractionRatio: number;
	wireframe: boolean;
	wireframeLinewidth: number;
	wireframeLinecap: string;
	wireframeLinejoin: string;
	skinning: boolean;
	morphTargets: boolean;
	morphNormals: boolean;

	setValues( parameters: MeshLambertMaterialParameters ): void;

}

export class MeshMatcapMaterial {
    constructor(parameters: any);

    copy(source: any): any;

}

export class MeshNormalMaterial {
    constructor(parameters: any);

    copy(source: any): any;

}

export interface MeshPhongMaterialParameters extends MaterialParameters {
	/** geometry color in hexadecimal. Default is 0xffffff. */
	color?: Color | string | number;
	specular?: Color | string | number;
	shininess?: number;
	opacity?: number;
	map?: Texture | null;
	lightMap?: Texture | null;
	lightMapIntensity?: number;
	aoMap?: Texture | null;
	aoMapIntensity?: number;
	emissive?: Color | string | number;
	emissiveIntensity?: number;
	emissiveMap?: Texture | null;
	bumpMap?: Texture | null;
	bumpScale?: number;
	normalMap?: Texture | null;
	normalMapType?: NormalMapTypes;
	normalScale?: Vector2;
	displacementMap?: Texture | null;
	displacementScale?: number;
	displacementBias?: number;
	specularMap?: Texture | null;
	alphaMap?: Texture | null;
	envMap?: Texture | null;
	combine?: Combine;
	reflectivity?: number;
	refractionRatio?: number;
	wireframe?: boolean;
	wireframeLinewidth?: number;
	wireframeLinecap?: string;
	wireframeLinejoin?: string;
	skinning?: boolean;
	morphTargets?: boolean;
	morphNormals?: boolean;
}

export class MeshPhongMaterial extends Material {

	constructor( parameters?: MeshPhongMaterialParameters );

	color: Color;
	specular: Color;
	shininess: number;
	map: Texture | null;
	lightMap: Texture | null;
	lightMapIntensity: number;
	aoMap: Texture | null;
	aoMapIntensity: number;
	emissive: Color;
	emissiveIntensity: number;
	emissiveMap: Texture | null;
	bumpMap: Texture | null;
	bumpScale: number;
	normalMap: Texture | null;
	normalMapType: NormalMapTypes;
	normalScale: Vector2;
	displacementMap: Texture | null;
	displacementScale: number;
	displacementBias: number;
	specularMap: Texture | null;
	alphaMap: Texture | null;
	envMap: Texture | null;
	combine: Combine;
	reflectivity: number;
	refractionRatio: number;
	wireframe: boolean;
	wireframeLinewidth: number;
	wireframeLinecap: string;
	wireframeLinejoin: string;
	skinning: boolean;
	morphTargets: boolean;
	morphNormals: boolean;
	/**
	 * @deprecated Use {@link MeshStandardMaterial THREE.MeshStandardMaterial} instead.
	 */
	metal: boolean;

	setValues( parameters: MeshPhongMaterialParameters ): void;

}

export class MeshPhysicalMaterial {
    constructor(parameters: any);

    copy(source: any): any;

}

export class MeshStandardMaterial {
    constructor(parameters: any);

    copy(source: any): any;

}

export class MeshToonMaterial {
    constructor(parameters: any);

    copy(source: any): any;

}

export class NumberKeyframeTrack {
    constructor(name: any, times: any, values: any, interpolation: any);

}

export class Object3D extends EventDispatcher {
    constructor();

	/**
	 * Unique number of this object instance.
	 */
	id: number;

	/**
	 *
	 */
	uuid: string;

	/**
	 * Optional name of the object (doesn't need to be unique).
	 */
	name: string;

	type: string;

	/**
	 * Object's parent in the scene graph.
	 */
	parent: Object3D | null;

	/**
	 * Array with object's children.
	 */
	children: Object3D[];

	/**
	 * Up direction.
	 */
	up: Vector3;

	/**
	 * Object's local position.
	 */
	readonly position: Vector3;

	/**
	 * Object's local rotation (Euler angles), in radians.
	 */
	readonly rotation: Euler;

	/**
	 * Global rotation.
	 */
	readonly quaternion: Quaternion;

	/**
	 * Object's local scale.
	 */
	readonly scale: Vector3;

	readonly modelViewMatrix: Matrix4;

	readonly normalMatrix: Matrix3;

	/**
	 * Local transform.
	 */
	matrix: Matrix4;

	/**
	 * The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.
	 */
	matrixWorld: Matrix4;

	/**
	 * When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also recalculates the matrixWorld property.
	 */
	matrixAutoUpdate: boolean;

	/**
	 * When this is set, it calculates the matrixWorld in that frame and resets this property to false.
	 */
	matrixWorldNeedsUpdate: boolean;

	layers: Layers;
	/**
	 * Object gets rendered if true.
	 */
	visible: boolean;

	/**
	 * Gets rendered into shadow map.
	 */
	castShadow: boolean;

	/**
	 * Material gets baked in shadow receiving.
	 */
	receiveShadow: boolean;

	/**
	 * When this is set, it checks every frame if the object is in the frustum of the camera. Otherwise the object gets drawn every frame even if it isn't visible.
	 */
	frustumCulled: boolean;

	/**
	 * Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder. Opaque and transparent objects remain sorted independently though. When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.
	 */
	renderOrder: number;

	/**
	 * An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.
	 */
	userData: { [key: string]: any };

	/**
	 * Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.
	 * When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in
	 * the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a
	 * transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.
	 */
	customDepthMaterial: Material;

	/**
	 * Same as customDepthMaterial, but used with PointLight.
	 */
	customDistanceMaterial: Material;

	/**
	 * Used to check whether this or derived classes are Object3Ds. Default is true.
	 * You should not change this, as it is used internally for optimisation.
	 */
	readonly isObject3D: true;

	/**
	 * Calls before rendering object
	 */
	onBeforeRender: (
		renderer: WebGLRenderer,
		scene: Scene,
		camera: Camera,
		geometry: Geometry | BufferGeometry,
		material: Material,
		group: Group
	) => void;

	/**
	 * Calls after rendering object
	 */
	onAfterRender: (
		renderer: WebGLRenderer,
		scene: Scene,
		camera: Camera,
		geometry: Geometry | BufferGeometry,
		material: Material,
		group: Group
	) => void;

	static DefaultUp: Vector3;
	static DefaultMatrixAutoUpdate: boolean;

	/**
	 * This updates the position, rotation and scale with the matrix.
	 */
	applyMatrix4( matrix: Matrix4 ): void;

	applyQuaternion( quaternion: Quaternion ): this;

	/**
	 *
	 */
	setRotationFromAxisAngle( axis: Vector3, angle: number ): void;

	/**
	 *
	 */
	setRotationFromEuler( euler: Euler ): void;

	/**
	 *
	 */
	setRotationFromMatrix( m: Matrix4 ): void;

	/**
	 *
	 */
	setRotationFromQuaternion( q: Quaternion ): void;

	/**
	 * Rotate an object along an axis in object space. The axis is assumed to be normalized.
	 * @param axis	A normalized vector in object space.
	 * @param angle	The angle in radians.
	 */
	rotateOnAxis( axis: Vector3, angle: number ): this;

	/**
	 * Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.
	 * @param axis	A normalized vector in object space.
	 * @param angle	The angle in radians.
	 */
	rotateOnWorldAxis( axis: Vector3, angle: number ): this;

	/**
	 *
	 * @param angle
	 */
	rotateX( angle: number ): this;

	/**
	 *
	 * @param angle
	 */
	rotateY( angle: number ): this;

	/**
	 *
	 * @param angle
	 */
	rotateZ( angle: number ): this;

	/**
	 * @param axis	A normalized vector in object space.
	 * @param distance	The distance to translate.
	 */
	translateOnAxis( axis: Vector3, distance: number ): this;

	/**
	 * Translates object along x axis by distance.
	 * @param distance Distance.
	 */
	translateX( distance: number ): this;

	/**
	 * Translates object along y axis by distance.
	 * @param distance Distance.
	 */
	translateY( distance: number ): this;

	/**
	 * Translates object along z axis by distance.
	 * @param distance Distance.
	 */
	translateZ( distance: number ): this;

	/**
	 * Updates the vector from local space to world space.
	 * @param vector A local vector.
	 */
	localToWorld( vector: Vector3 ): Vector3;

	/**
	 * Updates the vector from world space to local space.
	 * @param vector A world vector.
	 */
	worldToLocal( vector: Vector3 ): Vector3;

	/**
	 * Rotates object to face point in space.
	 * @param vector A world vector to look at.
	 */
	lookAt( vector: Vector3 | number, y?: number, z?: number ): void;

	/**
	 * Adds object as child of this object.
	 */
	add( ...object: Object3D[] ): this;

	/**
	 * Removes object as child of this object.
	 */
	remove( ...object: Object3D[] ): this;

	/**
	 * Adds object as a child of this, while maintaining the object's world transform.
	 */
	attach( object: Object3D ): this;

	/**
	 * Searches through the object's children and returns the first with a matching id.
	 * @param id	Unique number of the object instance
	 */
	getObjectById( id: number ): Object3D | undefined;

	/**
	 * Searches through the object's children and returns the first with a matching name.
	 * @param name	String to match to the children's Object3d.name property.
	 */
	getObjectByName( name: string ): Object3D | undefined;

	getObjectByProperty( name: string, value: string ): Object3D | undefined;

	getWorldPosition( target: Vector3 ): Vector3;
	getWorldQuaternion( target: Quaternion ): Quaternion;
	getWorldScale( target: Vector3 ): Vector3;
	getWorldDirection( target: Vector3 ): Vector3;

	raycast( raycaster: Raycaster, intersects: Intersection[] ): void;

	traverse( callback: ( object: Object3D ) => any ): void;

	traverseVisible( callback: ( object: Object3D ) => any ): void;

	traverseAncestors( callback: ( object: Object3D ) => any ): void;

	/**
	 * Updates local transform.
	 */
	updateMatrix(): void;

	/**
	 * Updates global transform of the object and its children.
	 */
	updateMatrixWorld( force?: boolean ): void;

	updateWorldMatrix( updateParents: boolean, updateChildren: boolean ): void;

	toJSON( meta?: {
		geometries: any;
		materials: any;
		textures: any;
		images: any;
	} ): any;

	clone( recursive?: boolean ): this;

	/**
	 *
	 * @param object
	 * @param recursive
	 */
	copy( source: this, recursive?: boolean ): this;
}

export class ObjectLoader extends Loader {

	constructor( manager?: LoadingManager );

	load(
		url: string,
		onLoad?: <ObjectType extends Object3D>( object: ObjectType ) => void,
		onProgress?: ( event: ProgressEvent ) => void,
		onError?: ( event: Error | ErrorEvent ) => void
	): void;
	parse<T extends Object3D>( json: any, onLoad?: ( object: Object3D ) => void ): T;
	parseGeometries( json: any ): any[]; // Array of BufferGeometry or Geometry or Geometry2.
	parseMaterials( json: any, textures: Texture[] ): Material[]; // Array of Classes that inherits from Matrial.
	parseAnimations( json: any ): AnimationClip[];
	parseImages(
		json: any,
		onLoad: () => void
	): { [key: string]: HTMLImageElement };
	parseTextures( json: any, images: any ): Texture[];
	parseObject<T extends Object3D>(
		data: any,
		geometries: any[],
		materials: Material[]
	): T;

}

export class OrthographicCamera extends Camera {

	/**
	 * @param left Camera frustum left plane.
	 * @param right Camera frustum right plane.
	 * @param top Camera frustum top plane.
	 * @param bottom Camera frustum bottom plane.
	 * @param near Camera frustum near plane.
	 * @param far Camera frustum far plane.
	 */
	constructor(
		left: number,
		right: number,
		top: number,
		bottom: number,
		near?: number,
		far?: number
	);

	type: 'OrthographicCamera';

	readonly isOrthographicCamera: true;

	zoom: number;
	view: null | {
		enabled: boolean;
		fullWidth: number;
		fullHeight: number;
		offsetX: number;
		offsetY: number;
		width: number;
		height: number;
	};

	/**
	 * Camera frustum left plane.
	 */
	left: number;

	/**
	 * Camera frustum right plane.
	 */
	right: number;

	/**
	 * Camera frustum top plane.
	 */
	top: number;

	/**
	 * Camera frustum bottom plane.
	 */
	bottom: number;

	/**
	 * Camera frustum near plane.
	 */
	near: number;

	/**
	 * Camera frustum far plane.
	 */
	far: number;

	/**
	 * Updates the camera projection matrix. Must be called after change of parameters.
	 */
	updateProjectionMatrix(): void;
	setViewOffset(
		fullWidth: number,
		fullHeight: number,
		offsetX: number,
		offsetY: number,
		width: number,
		height: number
	): void;
	clearViewOffset(): void;
	toJSON( meta?: any ): any;

}

export class PMREMGenerator {
    constructor(renderer: any);

    compileCubemapShader(): void;

    compileEquirectangularShader(): void;

    dispose(): void;

    fromCubemap(cubemap: any): any;

    fromEquirectangular(equirectangular: any): any;

    fromScene(scene: any, sigma: any, near: any, far: any): any;

}

export class Path {
    constructor(points: any);

    absarc(aX: any, aY: any, aRadius: any, aStartAngle: any, aEndAngle: any, aClockwise: any): any;

    absellipse(aX: any, aY: any, xRadius: any, yRadius: any, aStartAngle: any, aEndAngle: any, aClockwise: any, aRotation: any): any;

    arc(aX: any, aY: any, aRadius: any, aStartAngle: any, aEndAngle: any, aClockwise: any): any;

    bezierCurveTo(aCP1x: any, aCP1y: any, aCP2x: any, aCP2y: any, aX: any, aY: any): any;

    copy(source: any): any;

    ellipse(aX: any, aY: any, xRadius: any, yRadius: any, aStartAngle: any, aEndAngle: any, aClockwise: any, aRotation: any): any;

    fromJSON(json: any): any;

    fromPoints(points: any): any;

    lineTo(x: any, y: any): any;

    moveTo(x: any, y: any): any;

    quadraticCurveTo(aCPx: any, aCPy: any, aX: any, aY: any): any;

    setFromPoints(points: any): any;

    splineThru(pts: any): any;

    toJSON(): any;

}

export class PerspectiveCamera extends Camera {
    /**
	 * @param fov Camera frustum vertical field of view. Default value is 50.
	 * @param aspect Camera frustum aspect ratio. Default value is 1.
	 * @param near Camera frustum near plane. Default value is 0.1.
	 * @param far Camera frustum far plane. Default value is 2000.
	 */
	constructor( fov?: number, aspect?: number, near?: number, far?: number );

	type: 'PerspectiveCamera';

	readonly isPerspectiveCamera: true;

	zoom: number;

	/**
	 * Camera frustum vertical field of view, from bottom to top of view, in degrees.
	 */
	fov: number;

	/**
	 * Camera frustum aspect ratio, window width divided by window height.
	 */
	aspect: number;

	/**
	 * Camera frustum near plane.
	 */
	near: number;

	/**
	 * Camera frustum far plane.
	 */
	far: number;

	focus: number;
	view: null | {
		enabled: boolean;
		fullWidth: number;
		fullHeight: number;
		offsetX: number;
		offsetY: number;
		width: number;
		height: number;
	};
	filmGauge: number;
	filmOffset: number;

	setFocalLength( focalLength: number ): void;
	getFocalLength(): number;
	getEffectiveFOV(): number;
	getFilmWidth(): number;
	getFilmHeight(): number;

	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or multi-monitor/multi-machine setups.
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and the monitors are in grid like this:
	 *
	 *		 +---+---+---+
	 *		 | A | B | C |
	 *		 +---+---+---+
	 *		 | D | E | F |
	 *		 +---+---+---+
	 *
	 * then for each monitor you would call it like this:
	 *
	 *		 var w = 1920;
	 *		 var h = 1080;
	 *		 var fullWidth = w * 3;
	 *		 var fullHeight = h * 2;
	 *
	 *		 // A
	 *		 camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *		 // B
	 *		 camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *		 // C
	 *		 camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *		 // D
	 *		 camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *		 // E
	 *		 camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *		 // F
	 *		 camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h ); Note there is no reason monitors have to be the same size or in a grid.
	 *
	 * @param fullWidth full width of multiview setup
	 * @param fullHeight full height of multiview setup
	 * @param x horizontal offset of subcamera
	 * @param y vertical offset of subcamera
	 * @param width width of subcamera
	 * @param height height of subcamera
	 */
	setViewOffset(
		fullWidth: number,
		fullHeight: number,
		x: number,
		y: number,
		width: number,
		height: number
	): void;
	clearViewOffset(): void;

	/**
	 * Updates the camera projection matrix. Must be called after change of parameters.
	 */
	updateProjectionMatrix(): void;
	toJSON( meta?: any ): any;

	/**
	 * @deprecated Use {@link PerspectiveCamera#setFocalLength .setFocalLength()} and {@link PerspectiveCamera#filmGauge .filmGauge} instead.
	 */
	setLens( focalLength: number, frameHeight?: number ): void;

}

export class Plane {
    constructor(normal: any, constant: any);

    applyMatrix4(matrix: any, optionalNormalMatrix: any): any;

    clone(): any;

    coplanarPoint(target: any): any;

    copy(plane: any): any;

    distanceToPoint(point: any): any;

    distanceToSphere(sphere: any): any;

    equals(plane: any): any;

    intersectLine(line: any, target: any): any;

    intersectsBox(box: any): any;

    intersectsLine(line: any): any;

    intersectsSphere(sphere: any): any;

    isIntersectionLine(line: any): any;

    negate(): any;

    normalize(): any;

    projectPoint(point: any, target: any): any;

    set(normal: any, constant: any): any;

    setComponents(x: any, y: any, z: any, w: any): any;

    setFromCoplanarPoints(a: any, b: any, c: any): any;

    setFromNormalAndCoplanarPoint(normal: any, point: any): any;

    translate(offset: any): any;

}

export class PlaneHelper {
    constructor(plane: any, size: any, hex: any);

    updateMatrixWorld(force: any): void;

}

export class PointLight {
    constructor(color: any, intensity: any, distance: any, decay: any);

    copy(source: any): any;

}

export class PointLightHelper {
    constructor(light: any, sphereSize: any, color: any);

    dispose(): void;

    update(): void;

}

export class Points {
    constructor(geometry: any, material: any);

    clone(): any;

    raycast(raycaster: any, intersects: any): void;

    updateMorphTargets(): void;

}

export class PointsMaterial {
    constructor(parameters: any);

    copy(source: any): any;

}

export class PositionalAudio {
    constructor(listener: any);

    getDistanceModel(): any;

    getMaxDistance(): any;

    getOutput(): any;

    getRefDistance(): any;

    getRolloffFactor(): any;

    setDirectionalCone(coneInnerAngle: any, coneOuterAngle: any, coneOuterGain: any): any;

    setDistanceModel(value: any): any;

    setMaxDistance(value: any): any;

    setRefDistance(value: any): any;

    setRolloffFactor(value: any): any;

    updateMatrixWorld(force: any): void;

}

export class PropertyBinding {
    constructor(rootNode: any, path: any, parsedPath: any);

    bind(): void;

    getValue(targetArray: any, offset: any): void;

    setValue(sourceArray: any, offset: any): void;

    unbind(): void;

    static create(root: any, path: any, parsedPath: any): any;

    static findNode(root: any, nodeName: any): any;

    static parseTrackName(trackName: any): any;

    static sanitizeNodeName(name: any): any;

}

export class PropertyMixer {
    constructor(binding: any, typeName: any, valueSize: any);

    accumulate(accuIndex: any, weight: any): void;

    accumulateAdditive(weight: any): void;

    apply(accuIndex: any): void;

    restoreOriginalState(): void;

    saveOriginalState(): void;

}

export class QuadraticBezierCurve {
    constructor(v0: any, v1: any, v2: any);

    copy(source: any): any;

    fromJSON(json: any): any;

    getPoint(t: any, optionalTarget: any): any;

    toJSON(): any;

}

export class QuadraticBezierCurve3 {
    constructor(v0: any, v1: any, v2: any);

    copy(source: any): any;

    fromJSON(json: any): any;

    getPoint(t: any, optionalTarget: any): any;

    toJSON(): any;

}

export class Quaternion {
    constructor(x: any, y: any, z: any, w: any);

    angleTo(q: any): any;

    clone(): any;

    conjugate(): any;

    copy(quaternion: any): any;

    dot(v: any): any;

    equals(quaternion: any): any;

    fromArray(array: any, offset: any): any;

    fromBufferAttribute(attribute: any, index: any): any;

    inverse(): any;

    length(): any;

    lengthSq(): any;

    multiply(q: any, p: any): any;

    multiplyQuaternions(a: any, b: any): any;

    multiplyVector3(vector: any): any;

    normalize(): any;

    premultiply(q: any): any;

    rotateTowards(q: any, step: any): any;

    set(x: any, y: any, z: any, w: any): any;

    setFromAxisAngle(axis: any, angle: any): any;

    setFromEuler(euler: any, update: any): any;

    setFromRotationMatrix(m: any): any;

    setFromUnitVectors(vFrom: any, vTo: any): any;

    slerp(qb: any, t: any): any;

    toArray(array: any, offset: any): any;

    static multiplyQuaternionsFlat(dst: any, dstOffset: any, src0: any, srcOffset0: any, src1: any, srcOffset1: any): any;

    static slerp(qa: any, qb: any, qm: any, t: any): any;

    static slerpFlat(dst: any, dstOffset: any, src0: any, srcOffset0: any, src1: any, srcOffset1: any, t: any): void;

}

export class QuaternionKeyframeTrack {
    constructor(name: any, times: any, values: any, interpolation: any);

    InterpolantFactoryMethodLinear(result: any): any;

}

export class QuaternionLinearInterpolant {
    constructor(parameterPositions: any, sampleValues: any, sampleSize: any, resultBuffer: any);

    interpolate_(i1: any, t0: any, t: any, t1: any): any;

}

export class RawShaderMaterial {
    constructor(parameters: any);

}

export class Ray {
    constructor(origin: any, direction: any);

    applyMatrix4(matrix4: any): any;

    at(t: any, target: any): any;

    clone(): any;

    closestPointToPoint(point: any, target: any): any;

    copy(ray: any): any;

    distanceSqToPoint(point: any): any;

    distanceSqToSegment(v0: any, v1: any, optionalPointOnRay: any, optionalPointOnSegment: any): any;

    distanceToPlane(plane: any): any;

    distanceToPoint(point: any): any;

    equals(ray: any): any;

    intersectBox(box: any, target: any): any;

    intersectPlane(plane: any, target: any): any;

    intersectSphere(sphere: any, target: any): any;

    intersectTriangle(a: any, b: any, c: any, backfaceCulling: any, target: any): any;

    intersectsBox(box: any): any;

    intersectsPlane(plane: any): any;

    intersectsSphere(sphere: any): any;

    isIntersectionBox(box: any): any;

    isIntersectionPlane(plane: any): any;

    isIntersectionSphere(sphere: any): any;

    lookAt(v: any): any;

    recast(t: any): any;

    set(origin: any, direction: any): any;

}

export interface Intersection {
	distance: number;
	distanceToRay?: number;
	point: Vector3;
	index?: number;
	face?: Face3 | null;
	faceIndex?: number;
	object: Object3D;
	uv?: Vector2;
	instanceId?: number;
}

export interface RaycasterParameters {
	Mesh?: any;
	Line?: { threshold: number };
	LOD?: any;
	Points?: { threshold: number };
	Sprite?: any;
}

export class Raycaster {

	/**
	 * This creates a new raycaster object.
	 * @param origin The origin vector where the ray casts from.
	 * @param direction The direction vector that gives direction to the ray. Should be normalized.
	 * @param near All results returned are further away than near. Near can't be negative. Default value is 0.
	 * @param far All results returned are closer then far. Far can't be lower then near . Default value is Infinity.
	 */
	constructor(
		origin?: Vector3,
		direction?: Vector3,
		near?: number,
		far?: number
	);

	/** The Ray used for the raycasting. */
	ray: Ray;

	/**
	 * The near factor of the raycaster. This value indicates which objects can be discarded based on the
	 * distance. This value shouldn't be negative and should be smaller than the far property.
	 */
	near: number;

	/**
	 * The far factor of the raycaster. This value indicates which objects can be discarded based on the
	 * distance. This value shouldn't be negative and should be larger than the near property.
	 */
	far: number;

	/**
	 * The camera to use when raycasting against view-dependent objects such as billboarded objects like Sprites. This field
	 * can be set manually or is set when calling "setFromCamera".
	 */
	camera: Camera;

	/**
	 * Used by Raycaster to selectively ignore 3D objects when performing intersection tests.
	 */
	layers: Layers;

	params: RaycasterParameters;

	/**
	 * Updates the ray with a new origin and direction.
	 * @param origin The origin vector where the ray casts from.
	 * @param direction The normalized direction vector that gives direction to the ray.
	 */
	set( origin: Vector3, direction: Vector3 ): void;

	/**
	 * Updates the ray with a new origin and direction.
	 * @param coords 2D coordinates of the mouse, in normalized device coordinates (NDC)---X and Y components should be between -1 and 1.
	 * @param camera camera from which the ray should originate
	 */
	setFromCamera( coords: { x: number; y: number }, camera: Camera ): void;

	/**
	 * Checks all intersection between the ray and the object with or without the descendants. Intersections are returned sorted by distance, closest first.
	 * @param object The object to check for intersection with the ray.
	 * @param recursive If true, it also checks all descendants. Otherwise it only checks intersecton with the object. Default is false.
	 * @param optionalTarget (optional) target to set the result. Otherwise a new Array is instantiated. If set, you must clear this array prior to each call (i.e., array.length = 0;).
	 */
	intersectObject(
		object: Object3D,
		recursive?: boolean,
		optionalTarget?: Intersection[]
	): Intersection[];

	/**
	 * Checks all intersection between the ray and the objects with or without the descendants. Intersections are returned sorted by distance, closest first. Intersections are of the same form as those returned by .intersectObject.
	 * @param objects The objects to check for intersection with the ray.
	 * @param recursive If true, it also checks all descendants of the objects. Otherwise it only checks intersecton with the objects. Default is false.
	 * @param optionalTarget (optional) target to set the result. Otherwise a new Array is instantiated. If set, you must clear this array prior to each call (i.e., array.length = 0;).
	 */
	intersectObjects(
		objects: Object3D[],
		recursive?: boolean,
		optionalTarget?: Intersection[]
	): Intersection[];

}

export class RectAreaLight {
    constructor(color: any, intensity: any, width: any, height: any);

    copy(source: any): any;

    toJSON(meta: any): any;

}

export class Scene extends Object3D{
    constructor();

	type: 'Scene';

	/**
	 * A fog instance defining the type of fog that affects everything rendered in the scene. Default is null.
	 */
	fog: IFog | null;

	/**
	 * If not null, it will force everything in the scene to be rendered with that material. Default is null.
	 */
	overrideMaterial: Material | null;
	autoUpdate: boolean;
	background: null | Color | Texture;
	environment: null | Texture;

	readonly isScene: true;

	/**
	 * Calls before rendering scene
	 */
	onBeforeRender: (
		renderer: WebGLRenderer,
		scene: Scene,
		camera: Camera,
		renderTarget: RenderTarget
	) => void;

	/**
	 * Calls after rendering scene
	 */
	onAfterRender: (
		renderer: WebGLRenderer,
		scene: Scene,
		camera: Camera
	) => void;

	toJSON( meta?: any ): any;
	dispose(): void;
}

export class ShaderMaterial {
    constructor(parameters: any);

    copy(source: any): any;

    toJSON(meta: any): any;

}

export class ShadowMaterial {
    constructor(parameters: any);

    copy(source: any): any;

}

export class Shape {
    constructor(points: any);

    copy(source: any): any;

    extractAllPoints(divisions: any): any;

    extractPoints(divisions: any): any;

    extrude(options: any): any;

    fromJSON(json: any): any;

    getPointsHoles(divisions: any): any;

    makeGeometry(options: any): any;

    toJSON(): any;

}

export class ShapeBufferGeometry {
    constructor(shapes: any, curveSegments: any);

    toJSON(): any;

}

export class ShapeGeometry {
    constructor(shapes: any, curveSegments: any);

    toJSON(): any;

}

export class ShapePath {
    constructor();

    bezierCurveTo(aCP1x: any, aCP1y: any, aCP2x: any, aCP2y: any, aX: any, aY: any): any;

    lineTo(x: any, y: any): any;

    moveTo(x: any, y: any): any;

    quadraticCurveTo(aCPx: any, aCPy: any, aX: any, aY: any): any;

    splineThru(pts: any): any;

    toShapes(isCCW: any, noHoles: any): any;

}

export class Skeleton {
    constructor(bones: any, boneInverses: any);

    calculateInverses(): void;

    clone(): any;

    dispose(): void;

    getBoneByName(name: any): any;

    pose(): void;

    update(): void;

}

export class SkeletonHelper {
    constructor(object: any);

    update(): void;

    updateMatrixWorld(force: any): void;

}

export class SkinnedMesh {
    constructor(geometry: any, material: any);

    bind(skeleton: any, bindMatrix: any): void;

    boneTransform(index: any, target: any): any;

    clone(): any;

    initBones(): void;

    normalizeSkinWeights(): void;

    pose(): void;

    updateMatrixWorld(force: any): void;

}

export class Sphere {
    constructor(center: any, radius: any);

    applyMatrix4(matrix: any): any;

    clampPoint(point: any, target: any): any;

    clone(): any;

    containsPoint(point: any): any;

    copy(sphere: any): any;

    distanceToPoint(point: any): any;

    empty(): any;

    equals(sphere: any): any;

    getBoundingBox(target: any): any;

    intersectsBox(box: any): any;

    intersectsPlane(plane: any): any;

    intersectsSphere(sphere: any): any;

    isEmpty(): any;

    makeEmpty(): any;

    set(center: any, radius: any): any;

    setFromPoints(points: any, optionalCenter: any): any;

    translate(offset: any): any;

}

export class Spherical {
    constructor(radius: any, phi: any, theta: any);

    clone(): any;

    copy(other: any): any;

    makeSafe(): any;

    set(radius: any, phi: any, theta: any): any;

    setFromCartesianCoords(x: any, y: any, z: any): any;

    setFromVector3(v: any): any;

}

export class SphericalHarmonics3 {
    constructor();

    add(sh: any): any;

    addScaledSH(sh: any, s: any): any;

    clone(): any;

    copy(sh: any): any;

    equals(sh: any): any;

    fromArray(array: any, offset: any): any;

    getAt(normal: any, target: any): any;

    getIrradianceAt(normal: any, target: any): any;

    lerp(sh: any, alpha: any): any;

    scale(s: any): any;

    set(coefficients: any): any;

    toArray(array: any, offset: any): any;

    zero(): any;

    static getBasisAt(normal: any, shBasis: any): void;

}

export class WebGLObjects {

	constructor(
		gl: WebGLRenderingContext,
		geometries: any,
		attributes: any,
		info: any
	);

	update( object: any ): any;
	dispose(): void;

}
export interface WebGLCapabilitiesParameters {
	precision?: string;
	logarithmicDepthBuffer?: boolean;
}

export class WebGLCapabilities {

	constructor(
		gl: WebGLRenderingContext,
		extensions: any,
		parameters: WebGLCapabilitiesParameters
	);

	readonly isWebGL2: boolean;
	precision: string;
	logarithmicDepthBuffer: boolean;
	maxTextures: number;
	maxVertexTextures: number;
	maxTextureSize: number;
	maxCubemapSize: number;
	maxAttributes: number;
	maxVertexUniforms: number;
	maxVaryings: number;
	maxFragmentUniforms: number;
	vertexTextures: boolean;
	floatFragmentTextures: boolean;
	floatVertexTextures: boolean;

	getMaxAnisotropy(): number;
	getMaxPrecision( precision: string ): string;

}
export class WebGLProperties {

	constructor();

	get( object: any ): any;
	remove( object: any ): void;
	update( object: any, key: any, value: any ): any;
	dispose(): void;

}

export class WebGLShadowMap {

	constructor(
		_renderer: WebGLRenderer,
		_objects: WebGLObjects,
		maxTextureSize: number
	);

	enabled: boolean;
	autoUpdate: boolean;
	needsUpdate: boolean;
	type: ShadowMapType;

	render( shadowsArray: Light[], scene: Scene, camera: Camera ): void;

	/**
	 * @deprecated Use {@link WebGLShadowMap#renderReverseSided .shadowMap.renderReverseSided} instead.
	 */
	cullFace: any;

}

export class Spline {
    constructor(points: any);

    getControlPointsArray(): void;

    initFromArray(): void;

    reparametrizeByArcLength(): void;

}

export class SplineCurve {
    constructor(points: any);

    copy(source: any): any;

    fromJSON(json: any): any;

    getPoint(t: any, optionalTarget: any): any;

    toJSON(): any;

}

export class SpotLight {
    constructor(color: any, intensity: any, distance: any, angle: any, penumbra: any, decay: any);

    copy(source: any): any;

}

export class SpotLightHelper {
    constructor(light: any, color: any);

    dispose(): void;

    update(): void;

}

export class SpotLightShadow {
    constructor();

    updateMatrices(light: any): void;

}

export class Sprite {
    constructor(material: any);

    clone(): any;

    copy(source: any): any;

    raycast(raycaster: any, intersects: any): void;

}

export class SpriteMaterial {
    constructor(parameters: any);

    copy(source: any): any;

}

export class StereoCamera {
    constructor();

    update(camera: any): void;

}

export class StringKeyframeTrack {
    constructor(name: any, times: any, values: any, interpolation: any);

    // Native method; no parameter or return type inference available
    ValueBufferType(p0: any): any;

}

export class Texture {
    constructor(image: any, mapping: any, wrapS: any, wrapT: any, magFilter: any, minFilter: any, format: any, type: any, anisotropy: any, encoding: any);

    clone(): any;

    copy(source: any): any;

    dispose(): void;

    toJSON(meta: any): any;

    transformUv(uv: any): any;

    updateMatrix(): void;

    static DEFAULT_IMAGE: any;

    static DEFAULT_MAPPING: number;

}

export class TextureLoader {
    constructor(manager: any);

    load(url: any, onLoad: any, onProgress: any, onError: any): any;

}

export class Triangle {
    constructor(a: any, b: any, c: any);

    area(): any;

    barycoordFromPoint(point: any, target: any): any;

    clone(): any;

    closestPointToPoint(p: any, target: any): any;

    containsPoint(point: any): any;

    copy(triangle: any): any;

    equals(triangle: any): any;

    getArea(): any;

    getBarycoord(point: any, target: any): any;

    getMidpoint(target: any): any;

    getNormal(target: any): any;

    getPlane(target: any): any;

    getUV(point: any, uv1: any, uv2: any, uv3: any, target: any): any;

    intersectsBox(box: any): any;

    isFrontFacing(direction: any): any;

    midpoint(target: any): any;

    normal(target: any): any;

    plane(target: any): any;

    set(a: any, b: any, c: any): any;

    setFromPointsAndIndices(points: any, i0: any, i1: any, i2: any): any;

    static barycoordFromPoint(point: any, a: any, b: any, c: any, target: any): any;

    static containsPoint(point: any, a: any, b: any, c: any): any;

    static getBarycoord(point: any, a: any, b: any, c: any, target: any): any;

    static getNormal(a: any, b: any, c: any, target: any): any;

    static getUV(point: any, p1: any, p2: any, p3: any, uv1: any, uv2: any, uv3: any, target: any): any;

    static isFrontFacing(a: any, b: any, c: any, direction: any): any;

    static normal(a: any, b: any, c: any, target: any): any;

}

export class TubeBufferGeometry {
    constructor(path: any, tubularSegments: any, radius: any, radialSegments: any, closed: any);

    toJSON(): any;

}

export class Uniform {
    constructor(value: any, ...args: any[]);

    clone(): any;

    onUpdate(): any;

}

export class Vector2 {
    constructor(x: any, y: any);

    add(v: any, w: any): any;

    addScalar(s: any): any;

    addScaledVector(v: any, s: any): any;

    addVectors(a: any, b: any): any;

    angle(): any;

    applyMatrix3(m: any): any;

    ceil(): any;

    clamp(min: any, max: any): any;

    clampLength(min: any, max: any): any;

    clampScalar(minVal: any, maxVal: any): any;

    clone(): any;

    copy(v: any): any;

    cross(v: any): any;

    distanceTo(v: any): any;

    distanceToManhattan(v: any): any;

    distanceToSquared(v: any): any;

    divide(v: any): any;

    divideScalar(scalar: any): any;

    dot(v: any): any;

    equals(v: any): any;

    floor(): any;

    fromArray(array: any, offset: any): any;

    fromAttribute(attribute: any, index: any, offset: any): any;

    fromBufferAttribute(attribute: any, index: any, offset: any): any;

    getComponent(index: any): any;

    length(): any;

    lengthManhattan(): any;

    lengthSq(): any;

    lerp(v: any, alpha: any): any;

    lerpVectors(v1: any, v2: any, alpha: any): any;

    manhattanDistanceTo(v: any): any;

    manhattanLength(): any;

    max(v: any): any;

    min(v: any): any;

    multiply(v: any): any;

    multiplyScalar(scalar: any): any;

    negate(): any;

    normalize(): any;

    random(): any;

    rotateAround(center: any, angle: any): any;

    round(): any;

    roundToZero(): any;

    set(x: any, y: any): any;

    setComponent(index: any, value: any): any;

    setLength(length: any): any;

    setScalar(scalar: any): any;

    setX(x: any): any;

    setY(y: any): any;

    sub(v: any, w: any): any;

    subScalar(s: any): any;

    subVectors(a: any, b: any): any;

    toArray(array: any, offset: any): any;

}

export class Vector3 {
    constructor(x: any, y: any, z: any);

    add(v: any, w: any): any;

    addScalar(s: any): any;

    addScaledVector(v: any, s: any): any;

    addVectors(a: any, b: any): any;

    angleTo(v: any): any;

    applyAxisAngle(axis: any, angle: any): any;

    applyEuler(euler: any): any;

    applyMatrix3(m: any): any;

    applyMatrix4(m: any): any;

    applyNormalMatrix(m: any): any;

    applyProjection(m: any): any;

    applyQuaternion(q: any): any;

    ceil(): any;

    clamp(min: any, max: any): any;

    clampLength(min: any, max: any): any;

    clampScalar(minVal: any, maxVal: any): any;

    clone(): any;

    copy(v: any): any;

    cross(v: any, w: any): any;

    crossVectors(a: any, b: any): any;

    distanceTo(v: any): any;

    distanceToManhattan(v: any): any;

    distanceToSquared(v: any): any;

    divide(v: any): any;

    divideScalar(scalar: any): any;

    dot(v: any): any;

    equals(v: any): any;

    floor(): any;

    fromArray(array: any, offset: any): any;

    fromAttribute(attribute: any, index: any, offset: any): any;

    fromBufferAttribute(attribute: any, index: any, offset: any): any;

    getColumnFromMatrix(index: any, matrix: any): any;

    getComponent(index: any): any;

    getPositionFromMatrix(m: any): any;

    getScaleFromMatrix(m: any): any;

    length(): any;

    lengthManhattan(): any;

    lengthSq(): any;

    lerp(v: any, alpha: any): any;

    lerpVectors(v1: any, v2: any, alpha: any): any;

    manhattanDistanceTo(v: any): any;

    manhattanLength(): any;

    max(v: any): any;

    min(v: any): any;

    multiply(v: any, w: any): any;

    multiplyScalar(scalar: any): any;

    multiplyVectors(a: any, b: any): any;

    negate(): any;

    normalize(): any;

    project(camera: any): any;

    projectOnPlane(planeNormal: any): any;

    projectOnVector(v: any): any;

    random(): any;

    reflect(normal: any): any;

    round(): any;

    roundToZero(): any;

    set(x: any, y: any, z: any): any;

    setComponent(index: any, value: any): any;

    setEulerFromQuaternion(): void;

    setEulerFromRotationMatrix(): void;

    setFromCylindrical(c: any): any;

    setFromCylindricalCoords(radius: any, theta: any, y: any): any;

    setFromMatrix3Column(m: any, index: any): any;

    setFromMatrixColumn(m: any, index: any): any;

    setFromMatrixPosition(m: any): any;

    setFromMatrixScale(m: any): any;

    setFromSpherical(s: any): any;

    setFromSphericalCoords(radius: any, phi: any, theta: any): any;

    setLength(length: any): any;

    setScalar(scalar: any): any;

    setX(x: any): any;

    setY(y: any): any;

    setZ(z: any): any;

    sub(v: any, w: any): any;

    subScalar(s: any): any;

    subVectors(a: any, b: any): any;

    toArray(array: any, offset: any): any;

    transformDirection(m: any): any;

    unproject(camera: any): any;

}

export class WebGLInfo {

	constructor( gl: WebGLRenderingContext );

	autoReset: boolean;
	memory: {
		geometries: number;
		textures: number;
	};
	programs: WebGLProgram[] | null;
	render: {
		calls: number;
		frame: number;
		lines: number;
		points: number;
		triangles: number;
	};
	update( count: number, mode: GLenum, instanceCount: number ): void;
	reset(): void;

}

export class Vector4 {
    constructor(x: any, y: any, z: any, w: any);

    add(v: any, w: any): any;

    addScalar(s: any): any;

    addScaledVector(v: any, s: any): any;

    addVectors(a: any, b: any): any;

    applyMatrix4(m: any): any;

    ceil(): any;

    clamp(min: any, max: any): any;

    clampLength(min: any, max: any): any;

    clampScalar(minVal: any, maxVal: any): any;

    clone(): any;

    copy(v: any): any;

    divideScalar(scalar: any): any;

    dot(v: any): any;

    equals(v: any): any;

    floor(): any;

    fromArray(array: any, offset: any): any;

    fromAttribute(attribute: any, index: any, offset: any): any;

    fromBufferAttribute(attribute: any, index: any, offset: any): any;

    getComponent(index: any): any;

    length(): any;

    lengthManhattan(): any;

    lengthSq(): any;

    lerp(v: any, alpha: any): any;

    lerpVectors(v1: any, v2: any, alpha: any): any;

    manhattanLength(): any;

    max(v: any): any;

    min(v: any): any;

    multiplyScalar(scalar: any): any;

    negate(): any;

    normalize(): any;

    random(): any;

    round(): any;

    roundToZero(): any;

    set(x: any, y: any, z: any, w: any): any;

    setAxisAngleFromQuaternion(q: any): any;

    setAxisAngleFromRotationMatrix(m: any): any;

    setComponent(index: any, value: any): any;

    setLength(length: any): any;

    setScalar(scalar: any): any;

    setW(w: any): any;

    setX(x: any): any;

    setY(y: any): any;

    setZ(z: any): any;

    sub(v: any, w: any): any;

    subScalar(s: any): any;

    subVectors(a: any, b: any): any;

    toArray(array: any, offset: any): any;

}

export class VectorKeyframeTrack {
    constructor(name: any, times: any, values: any, interpolation: any);

}

export class VideoTexture {
    constructor(video: any, mapping: any, wrapS: any, wrapT: any, magFilter: any, minFilter: any, format: any, type: any, anisotropy: any);

    update(): void;

}

export class WebGLCubeRenderTarget {
    constructor(size: any, options: any, dummy: any);

    fromEquirectangularTexture(renderer: any, texture: any): any;

}

export class WebGLMultisampleRenderTarget {
    constructor(width: any, height: any, options: any);

    copy(source: any): any;

}

export class WebGLRenderTarget {
    constructor(width: any, height: any, options: any);

    clone(): any;

    copy(source: any): any;

    dispose(): void;

    setSize(width: any, height: any): void;

}

export class WebGLExtensions {

	constructor( gl: WebGLRenderingContext );

	get( name: string ): any;

}

export interface Renderer {
	domElement: HTMLCanvasElement;

	render( scene: Scene, camera: Camera ): void;
	setSize( width: number, height: number, updateStyle?: boolean ): void;
}

export interface WebGLRendererParameters {
	/**
	 * A Canvas where the renderer draws its output.
	 */
	canvas?: HTMLCanvasElement;

	/**
	 * A WebGL Rendering Context.
	 * (https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext)
	 *	Default is null
	 */
	context?: WebGLRenderingContext;

	/**
	 *	shader precision. Can be "highp", "mediump" or "lowp".
	 */
	precision?: string;

	/**
	 * default is false.
	 */
	alpha?: boolean;

	/**
	 * default is true.
	 */
	premultipliedAlpha?: boolean;

	/**
	 * default is false.
	 */
	antialias?: boolean;

	/**
	 * default is true.
	 */
	stencil?: boolean;

	/**
	 * default is false.
	 */
	preserveDrawingBuffer?: boolean;

	/**
	 *	Can be "high-performance", "low-power" or "default"
	 */
	powerPreference?: string;

	/**
	 * default is true.
	 */
	depth?: boolean;

	/**
	 * default is false.
	 */
	logarithmicDepthBuffer?: boolean;
}


export interface WebGLDebug {

	/**
	 * Enables error checking and reporting when shader programs are being compiled.
	 */
	checkShaderErrors: boolean;

}

export interface RenderTarget {} // not defined in the code, used in LightShadow and WebGRenderer classes

export interface RenderItem {
	id: number;
	object: Object3D;
	geometry: BufferGeometry | null;
	material: Material;
	program: WebGLProgram;
	groupOrder: number;
	renderOrder: number;
	z: number;
	group: Group | null;
}

export class WebGLRenderList {

	opaque: Array<RenderItem>;
	transparent: Array<RenderItem>;
	init(): void;
	push(
		object: Object3D,
		geometry: BufferGeometry | null,
		material: Material,
		groupOrder: number,
		z: number,
		group: Group | null
	): void;
	unshift(
		object: Object3D,
		geometry: BufferGeometry | null,
		material: Material,
		groupOrder: number,
		z: number,
		group: Group | null
	): void;
	sort( opaqueSort: Function, transparentSort: Function ): void;
	finish(): void;

}

export class WebGLRenderLists {

	dispose(): void;
	get( scene: Scene, camera: Camera ): WebGLRenderList;

}

export class WebGLColorBuffer {

	constructor();

	setMask( colorMask: boolean ): void;
	setLocked( lock: boolean ): void;
	setClear( r: number, g: number, b: number, a: number, premultipliedAlpha: boolean ): void;
	reset(): void;

}

export class WebGLDepthBuffer {

	constructor();

	setTest( depthTest: boolean ): void;
	setMask( depthMask: boolean ): void;
	setFunc( depthFunc: DepthModes ): void;
	setLocked( lock: boolean ): void;
	setClear( depth: number ): void;
	reset(): void;

}

export class WebGLStencilBuffer {

	constructor();

	setTest( stencilTest: boolean ): void;
	setMask( stencilMask: number ): void;
	setFunc( stencilFunc: number, stencilRef: number, stencilMask: number ): void;
	setOp( stencilFail: number, stencilZFail: number, stencilZPass: number ): void;
	setLocked( lock: boolean ): void;
	setClear( stencil: number ): void;
	reset(): void;

}

export class WebGLState {

	constructor( gl: WebGLRenderingContext, extensions: WebGLExtensions, capabilities: WebGLCapabilities );

	buffers: {
		color: WebGLColorBuffer;
		depth: WebGLDepthBuffer;
		stencil: WebGLStencilBuffer;
	};

	initAttributes(): void;
	enableAttribute( attribute: number ): void;
	enableAttributeAndDivisor( attribute: number, meshPerAttribute: number ): void;
	disableUnusedAttributes(): void;
	vertexAttribPointer( index: number, size: number, type: number, normalized: boolean, stride: number, offset: number ): void;
	enable( id: number ): void;
	disable( id: number ): void;
	useProgram( program: any ): boolean;
	setBlending(
		blending: Blending,
		blendEquation?: BlendingEquation,
		blendSrc?: BlendingSrcFactor,
		blendDst?: BlendingDstFactor,
		blendEquationAlpha?: BlendingEquation,
		blendSrcAlpha?: BlendingSrcFactor,
		blendDstAlpha?: BlendingDstFactor,
		premultiplyAlpha?: boolean
	): void;
	setMaterial( material: Material, frontFaceCW: boolean ): void;
	setFlipSided( flipSided: boolean ): void;
	setCullFace( cullFace: CullFace ): void;
	setLineWidth( width: number ): void;
	setPolygonOffset( polygonoffset: boolean, factor?: number, units?: number ): void;
	setScissorTest( scissorTest: boolean ): void;
	activeTexture( webglSlot: number ): void;
	bindTexture( webglType: number, webglTexture: any ): void;
	unbindTexture(): void;
	// Same interface as https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/compressedTexImage2D
	compressedTexImage2D(
		target: number,
		level: number,
		internalformat: number,
		width: number,
		height: number,
		border: number,
		data: ArrayBufferView
	): void;
	// Same interface as https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D
	texImage2D(
		target: number,
		level: number,
		internalformat: number,
		width: number,
		height: number,
		border: number,
		format: number,
		type: number,
		pixels: ArrayBufferView | null
	): void;
	texImage2D(
		target: number,
		level: number,
		internalformat: number,
		format: number,
		type: number,
		source: any
	): void;
	texImage3D(
		target: number,
		level: number,
		internalformat: number,
		width: number,
		height: number,
		depth: number,
		border: number,
		format: number,
		type: number,
		pixels: any
	): void;
	scissor( scissor: Vector4 ): void;
	viewport( viewport: Vector4 ): void;
	reset(): void;

}

export class WebXRManager {

	constructor( renderer: any, gl: WebGLRenderingContext );

	enabled: boolean;
	isPresenting: boolean;
	getController( id: number ): Group;
	getControllerGrip( id: number ): Group;
	setFramebufferScaleFactor( value: number ): void;
	setReferenceSpaceType( value: string ): void;
	getReferenceSpace(): any;
	getSession(): any;
	setSession( value: any ): void;
	getCamera( camera: Camera ): Camera;
	setAnimationLoop( callback: Function ): void;
	dispose(): void;

}

export class WebGLRenderer implements Renderer {
    /**
	 * parameters is an optional object with properties defining the renderer's behaviour. The constructor also accepts no parameters at all. In all cases, it will assume sane defaults when parameters are missing.
	 */
	constructor( parameters?: WebGLRendererParameters );

	/**
	 * A Canvas where the renderer draws its output.
	 * This is automatically created by the renderer in the constructor (if not provided already); you just need to add it to your page.
	 */
	domElement: HTMLCanvasElement;

	/**
	 * The HTML5 Canvas's 'webgl' context obtained from the canvas where the renderer will draw.
	 */
	context: WebGLRenderingContext;

	/**
	 * Defines whether the renderer should automatically clear its output before rendering.
	 */
	autoClear: boolean;

	/**
	 * If autoClear is true, defines whether the renderer should clear the color buffer. Default is true.
	 */
	autoClearColor: boolean;

	/**
	 * If autoClear is true, defines whether the renderer should clear the depth buffer. Default is true.
	 */
	autoClearDepth: boolean;

	/**
	 * If autoClear is true, defines whether the renderer should clear the stencil buffer. Default is true.
	 */
	autoClearStencil: boolean;

	/**
	 * Debug configurations.
	 */
	debug: WebGLDebug;

	/**
	 * Defines whether the renderer should sort objects. Default is true.
	 */
	sortObjects: boolean;

	clippingPlanes: any[];
	localClippingEnabled: boolean;

	extensions: WebGLExtensions;

	/**
	 * Default is LinearEncoding.
	 */
	outputEncoding: TextureEncoding;

	physicallyCorrectLights: boolean;
	toneMapping: ToneMapping;
	toneMappingExposure: number;
	toneMappingWhitePoint: number;

	/**
	 * Default is false.
	 */
	shadowMapDebug: boolean;

	/**
	 * Default is 8.
	 */
	maxMorphTargets: number;

	/**
	 * Default is 4.
	 */
	maxMorphNormals: number;

	info: WebGLInfo;

	shadowMap: WebGLShadowMap;

	pixelRatio: number;

	capabilities: WebGLCapabilities;
	properties: WebGLProperties;
	renderLists: WebGLRenderLists;
	state: WebGLState;

	xr: WebXRManager;

	/**
	 * Return the WebGL context.
	 */
	getContext(): WebGLRenderingContext;
	getContextAttributes(): any;
	forceContextLoss(): void;

	/**
	 * @deprecated Use {@link WebGLCapabilities#getMaxAnisotropy .capabilities.getMaxAnisotropy()} instead.
	 */
	getMaxAnisotropy(): number;

	/**
	 * @deprecated Use {@link WebGLCapabilities#precision .capabilities.precision} instead.
	 */
	getPrecision(): string;

	getPixelRatio(): number;
	setPixelRatio( value: number ): void;

	getDrawingBufferSize( target: Vector2 ): Vector2;
	setDrawingBufferSize( width: number, height: number, pixelRatio: number ): void;

	getSize( target: Vector2 ): Vector2;

	/**
	 * Resizes the output canvas to (width, height), and also sets the viewport to fit that size, starting in (0, 0).
	 */
	setSize( width: number, height: number, updateStyle?: boolean ): void;

	getCurrentViewport( target: Vector4 ): Vector4;

	/**
	 * Copies the viewport into target.
	 */
	getViewport( target: Vector4 ): Vector4;

	/**
	 * Sets the viewport to render from (x, y) to (x + width, y + height).
	 * (x, y) is the lower-left corner of the region.
	 */
	setViewport( x: Vector4 | number, y?: number, width?: number, height?: number ): void;

	/**
	 * Copies the scissor area into target.
	 */
	getScissor( target: Vector4 ): Vector4;

	/**
	 * Sets the scissor area from (x, y) to (x + width, y + height).
	 */
	setScissor( x: Vector4 | number, y?: number, width?: number, height?: number ): void;

	/**
	 * Returns true if scissor test is enabled; returns false otherwise.
	 */
	getScissorTest(): boolean;

	/**
	 * Enable the scissor test. When this is enabled, only the pixels within the defined scissor area will be affected by further renderer actions.
	 */
	setScissorTest( enable: boolean ): void;

	/**
	 * Sets the custom opaque sort function for the WebGLRenderLists. Pass null to use the default painterSortStable function.
	 */
	setOpaqueSort( method: Function ): void;

	/**
	 * Sets the custom transparent sort function for the WebGLRenderLists. Pass null to use the default reversePainterSortStable function.
	 */
	setTransparentSort( method: Function ): void;

	/**
	 * Returns a THREE.Color instance with the current clear color.
	 */
	getClearColor(): Color;

	/**
	 * Sets the clear color, using color for the color and alpha for the opacity.
	 */
	setClearColor( color: Color, alpha?: number ): void;
	setClearColor( color: string, alpha?: number ): void;
	setClearColor( color: number, alpha?: number ): void;

	/**
	 * Returns a float with the current clear alpha. Ranges from 0 to 1.
	 */
	getClearAlpha(): number;

	setClearAlpha( alpha: number ): void;

	/**
	 * Tells the renderer to clear its color, depth or stencil drawing buffer(s).
	 * Arguments default to true
	 */
	clear( color?: boolean, depth?: boolean, stencil?: boolean ): void;

	clearColor(): void;
	clearDepth(): void;
	clearStencil(): void;
	clearTarget(
		renderTarget: WebGLRenderTarget,
		color: boolean,
		depth: boolean,
		stencil: boolean
	): void;

	/**
	 * @deprecated Use {@link WebGLState#reset .state.reset()} instead.
	 */
	resetGLState(): void;
	dispose(): void;

	renderBufferImmediate(
		object: Object3D,
		program: WebGLProgram,
	): void;

	renderBufferDirect(
		camera: Camera,
		scene: Scene,
		geometry: Geometry | BufferGeometry,
		material: Material,
		object: Object3D,
		geometryGroup: any
	): void;

	/**
	 * A build in function that can be used instead of requestAnimationFrame. For WebXR projects this function must be used.
	 * @param callback The function will be called every available frame. If `null` is passed it will stop any already ongoing animation.
	 */
	setAnimationLoop( callback: Function | null ): void;

	/**
	 * @deprecated Use {@link WebGLRenderer#setAnimationLoop .setAnimationLoop()} instead.
	 */
	animate( callback: Function ): void;

	/**
	 * Compiles all materials in the scene with the camera. This is useful to precompile shaders before the first rendering.
	 */
	compile(
		scene: Scene,
		camera: Camera
	): void;

	/**
	 * Render a scene using a camera.
	 * The render is done to a previously specified {@link WebGLRenderTarget#renderTarget .renderTarget} set by calling
	 * {@link WebGLRenderer#setRenderTarget .setRenderTarget} or to the canvas as usual.
	 *
	 * By default render buffers are cleared before rendering but you can prevent this by setting the property
	 * {@link WebGLRenderer#autoClear autoClear} to false. If you want to prevent only certain buffers being cleared
	 * you can set either the {@link WebGLRenderer#autoClearColor autoClearColor},
	 * {@link WebGLRenderer#autoClearStencil autoClearStencil} or {@link WebGLRenderer#autoClearDepth autoClearDepth}
	 * properties to false. To forcibly clear one ore more buffers call {@link WebGLRenderer#clear .clear}.
	 */
	render(
		scene: Scene,
		camera: Camera
	): void;

	/**
	 * Returns the current active cube face.
	 */
	getActiveCubeFace(): number;

	/**
	 * Returns the current active mipmap level.
	 */
	getActiveMipmapLevel(): number;

	/**
	 * Sets the given WebGLFramebuffer. This method can only be used if no render target is set via
	 * {@link WebGLRenderer#setRenderTarget .setRenderTarget}.
	 *
	 * @param value The WebGLFramebuffer.
	 */
	setFramebuffer( value: WebGLFramebuffer ): void;

	/**
	 * Returns the current render target. If no render target is set, null is returned.
	 */
	getRenderTarget(): RenderTarget | null;

	/**
	 * @deprecated Use {@link WebGLRenderer#getRenderTarget .getRenderTarget()} instead.
	 */
	getCurrentRenderTarget(): RenderTarget | null;

	/**
	 * Sets the active render target.
	 *
	 * @param renderTarget The {@link WebGLRenderTarget renderTarget} that needs to be activated. When `null` is given, the canvas is set as the active render target instead.
	 * @param activeCubeFace Specifies the active cube side (PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5) of {@link WebGLCubeRenderTarget}.
	 * @param activeMipmapLevel Specifies the active mipmap level.
	 */
	setRenderTarget( renderTarget: RenderTarget | null, activeCubeFace?: number, activeMipmapLevel?: number ): void;

	readRenderTargetPixels(
		renderTarget: RenderTarget,
		x: number,
		y: number,
		width: number,
		height: number,
		buffer: any,
		activeCubeFaceIndex?: number
	): void;

	/**
	 * Copies a region of the currently bound framebuffer into the selected mipmap level of the selected texture.
	 * This region is defined by the size of the destination texture's mip level, offset by the input position.
	 *
	 * @param position Specifies the pixel offset from which to copy out of the framebuffer.
	 * @param texture Specifies the destination texture.
	 * @param level Specifies the destination mipmap level of the texture.
	 */
	copyFramebufferToTexture( position: Vector2, texture: Texture, level?: number ): void;

	/**
	 * Copies srcTexture to the specified level of dstTexture, offset by the input position.
	 *
	 * @param position Specifies the pixel offset into the dstTexture where the copy will occur.
	 * @param srcTexture Specifies the source texture.
	 * @param dstTexture Specifies the destination texture.
	 * @param level Specifies the destination mipmap level of the texture.
	 */
	copyTextureToTexture( position: Vector2, srcTexture: Texture, dstTexture: Texture, level?: number ): void;

	/**
	 * Initializes the given texture. Can be used to preload a texture rather than waiting until first render (which can cause noticeable lags due to decode and GPU upload overhead).
	 *
	 * @param texture The texture to Initialize.
	 */
	initTexture( texture: Texture ): void;

	/**
	 * @deprecated
	 */
	gammaFactor: number;

	/**
	 * @deprecated Use {@link WebGLRenderer#xr .xr} instead.
	 */
	vr: boolean;

	/**
	 * @deprecated Use {@link WebGLShadowMap#enabled .shadowMap.enabled} instead.
	 */
	shadowMapEnabled: boolean;

	/**
	 * @deprecated Use {@link WebGLShadowMap#type .shadowMap.type} instead.
	 */
	shadowMapType: ShadowMapType;

	/**
	 * @deprecated Use {@link WebGLShadowMap#cullFace .shadowMap.cullFace} instead.
	 */
	shadowMapCullFace: CullFace;

	/**
	 * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'OES_texture_float' )} instead.
	 */
	supportsFloatTextures(): any;

	/**
	 * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'OES_texture_half_float' )} instead.
	 */
	supportsHalfFloatTextures(): any;

	/**
	 * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'OES_standard_derivatives' )} instead.
	 */
	supportsStandardDerivatives(): any;

	/**
	 * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'WEBGL_compressed_texture_s3tc' )} instead.
	 */
	supportsCompressedTextureS3TC(): any;

	/**
	 * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'WEBGL_compressed_texture_pvrtc' )} instead.
	 */
	supportsCompressedTexturePVRTC(): any;

	/**
	 * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'EXT_blend_minmax' )} instead.
	 */
	supportsBlendMinMax(): any;

	/**
	 * @deprecated Use {@link WebGLCapabilities#vertexTextures .capabilities.vertexTextures} instead.
	 */
	supportsVertexTextures(): any;

	/**
	 * @deprecated Use {@link WebGLExtensions#get .extensions.get( 'ANGLE_instanced_arrays' )} instead.
	 */
	supportsInstancedArrays(): any;

	/**
	 * @deprecated Use {@link WebGLRenderer#setScissorTest .setScissorTest()} instead.
	 */
	enableScissorTest( boolean: any ): any;

}

export const FaceColors: number;

export const LinePieces: number;

export const LineStrip: number;

export const NoColors: number;

export const ShaderChunk: {
    alphamap_fragment: string;
    alphamap_pars_fragment: string;
    alphatest_fragment: string;
    aomap_fragment: string;
    aomap_pars_fragment: string;
    background_frag: string;
    background_vert: string;
    begin_vertex: string;
    beginnormal_vertex: string;
    bsdfs: string;
    bumpmap_pars_fragment: string;
    clearcoat_normal_fragment_begin: string;
    clearcoat_normal_fragment_maps: string;
    clearcoat_pars_fragment: string;
    clipping_planes_fragment: string;
    clipping_planes_pars_fragment: string;
    clipping_planes_pars_vertex: string;
    clipping_planes_vertex: string;
    color_fragment: string;
    color_pars_fragment: string;
    color_pars_vertex: string;
    color_vertex: string;
    common: string;
    cube_frag: string;
    cube_uv_reflection_fragment: string;
    cube_vert: string;
    defaultnormal_vertex: string;
    depth_frag: string;
    depth_vert: string;
    displacementmap_pars_vertex: string;
    displacementmap_vertex: string;
    distanceRGBA_frag: string;
    distanceRGBA_vert: string;
    dithering_fragment: string;
    dithering_pars_fragment: string;
    emissivemap_fragment: string;
    emissivemap_pars_fragment: string;
    encodings_fragment: string;
    encodings_pars_fragment: string;
    envmap_common_pars_fragment: string;
    envmap_fragment: string;
    envmap_pars_fragment: string;
    envmap_pars_vertex: string;
    envmap_physical_pars_fragment: string;
    envmap_vertex: string;
    equirect_frag: string;
    equirect_vert: string;
    fog_fragment: string;
    fog_pars_fragment: string;
    fog_pars_vertex: string;
    fog_vertex: string;
    gradientmap_pars_fragment: string;
    lightmap_fragment: string;
    lightmap_pars_fragment: string;
    lights_fragment_begin: string;
    lights_fragment_end: string;
    lights_fragment_maps: string;
    lights_lambert_vertex: string;
    lights_pars_begin: string;
    lights_phong_fragment: string;
    lights_phong_pars_fragment: string;
    lights_physical_fragment: string;
    lights_physical_pars_fragment: string;
    lights_toon_fragment: string;
    lights_toon_pars_fragment: string;
    linedashed_frag: string;
    linedashed_vert: string;
    logdepthbuf_fragment: string;
    logdepthbuf_pars_fragment: string;
    logdepthbuf_pars_vertex: string;
    logdepthbuf_vertex: string;
    map_fragment: string;
    map_pars_fragment: string;
    map_particle_fragment: string;
    map_particle_pars_fragment: string;
    meshbasic_frag: string;
    meshbasic_vert: string;
    meshlambert_frag: string;
    meshlambert_vert: string;
    meshmatcap_frag: string;
    meshmatcap_vert: string;
    meshphong_frag: string;
    meshphong_vert: string;
    meshphysical_frag: string;
    meshphysical_vert: string;
    meshtoon_frag: string;
    meshtoon_vert: string;
    metalnessmap_fragment: string;
    metalnessmap_pars_fragment: string;
    morphnormal_vertex: string;
    morphtarget_pars_vertex: string;
    morphtarget_vertex: string;
    normal_frag: string;
    normal_fragment_begin: string;
    normal_fragment_maps: string;
    normal_vert: string;
    normalmap_pars_fragment: string;
    packing: string;
    points_frag: string;
    points_vert: string;
    premultiplied_alpha_fragment: string;
    project_vertex: string;
    roughnessmap_fragment: string;
    roughnessmap_pars_fragment: string;
    shadow_frag: string;
    shadow_vert: string;
    shadowmap_pars_fragment: string;
    shadowmap_pars_vertex: string;
    shadowmap_vertex: string;
    shadowmask_pars_fragment: string;
    skinbase_vertex: string;
    skinning_pars_vertex: string;
    skinning_vertex: string;
    skinnormal_vertex: string;
    specularmap_fragment: string;
    specularmap_pars_fragment: string;
    sprite_frag: string;
    sprite_vert: string;
    tonemapping_fragment: string;
    tonemapping_pars_fragment: string;
    uv2_pars_fragment: string;
    uv2_pars_vertex: string;
    uv2_vertex: string;
    uv_pars_fragment: string;
    uv_pars_vertex: string;
    uv_vertex: string;
    worldpos_vertex: string;
};

export const ShaderLib: {
    background: {
        fragmentShader: string;
        uniforms: {
            t2D: {
                value: any;
            };
            uvTransform: {
                value: {
                    applyToBufferAttribute: any;
                    applyToVector3Array: any;
                    clone: any;
                    copy: any;
                    determinant: any;
                    elements: number[];
                    equals: any;
                    extractBasis: any;
                    flattenToArrayOffset: any;
                    fromArray: any;
                    getInverse: any;
                    getNormalMatrix: any;
                    identity: any;
                    isMatrix3: boolean;
                    multiply: any;
                    multiplyMatrices: any;
                    multiplyScalar: any;
                    multiplyVector3: any;
                    multiplyVector3Array: any;
                    premultiply: any;
                    rotate: any;
                    scale: any;
                    set: any;
                    setFromMatrix4: any;
                    setUvTransform: any;
                    toArray: any;
                    translate: any;
                    transpose: any;
                    transposeIntoArray: any;
                };
            };
        };
        vertexShader: string;
    };
    basic: {
        fragmentShader: string;
        uniforms: {
            alphaMap: {
                value: any;
            };
            aoMap: {
                value: any;
            };
            aoMapIntensity: {
                value: number;
            };
            diffuse: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            envMap: {
                value: any;
            };
            flipEnvMap: {
                value: number;
            };
            fogColor: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            fogDensity: {
                value: number;
            };
            fogFar: {
                value: number;
            };
            fogNear: {
                value: number;
            };
            lightMap: {
                value: any;
            };
            lightMapIntensity: {
                value: number;
            };
            map: {
                value: any;
            };
            maxMipLevel: {
                value: number;
            };
            opacity: {
                value: number;
            };
            reflectivity: {
                value: number;
            };
            refractionRatio: {
                value: number;
            };
            specularMap: {
                value: any;
            };
            uv2Transform: {
                value: {
                    applyToBufferAttribute: any;
                    applyToVector3Array: any;
                    clone: any;
                    copy: any;
                    determinant: any;
                    elements: number[];
                    equals: any;
                    extractBasis: any;
                    flattenToArrayOffset: any;
                    fromArray: any;
                    getInverse: any;
                    getNormalMatrix: any;
                    identity: any;
                    isMatrix3: boolean;
                    multiply: any;
                    multiplyMatrices: any;
                    multiplyScalar: any;
                    multiplyVector3: any;
                    multiplyVector3Array: any;
                    premultiply: any;
                    rotate: any;
                    scale: any;
                    set: any;
                    setFromMatrix4: any;
                    setUvTransform: any;
                    toArray: any;
                    translate: any;
                    transpose: any;
                    transposeIntoArray: any;
                };
            };
            uvTransform: {
                value: {
                    applyToBufferAttribute: any;
                    applyToVector3Array: any;
                    clone: any;
                    copy: any;
                    determinant: any;
                    elements: number[];
                    equals: any;
                    extractBasis: any;
                    flattenToArrayOffset: any;
                    fromArray: any;
                    getInverse: any;
                    getNormalMatrix: any;
                    identity: any;
                    isMatrix3: boolean;
                    multiply: any;
                    multiplyMatrices: any;
                    multiplyScalar: any;
                    multiplyVector3: any;
                    multiplyVector3Array: any;
                    premultiply: any;
                    rotate: any;
                    scale: any;
                    set: any;
                    setFromMatrix4: any;
                    setUvTransform: any;
                    toArray: any;
                    translate: any;
                    transpose: any;
                    transposeIntoArray: any;
                };
            };
        };
        vertexShader: string;
    };
    cube: {
        fragmentShader: string;
        uniforms: {
            envMap: {
                value: any;
            };
            flipEnvMap: {
                value: number;
            };
            maxMipLevel: {
                value: number;
            };
            opacity: {
                value: number;
            };
            reflectivity: {
                value: number;
            };
            refractionRatio: {
                value: number;
            };
        };
        vertexShader: string;
    };
    dashed: {
        fragmentShader: string;
        uniforms: {
            alphaMap: {
                value: any;
            };
            dashSize: {
                value: number;
            };
            diffuse: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            fogColor: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            fogDensity: {
                value: number;
            };
            fogFar: {
                value: number;
            };
            fogNear: {
                value: number;
            };
            map: {
                value: any;
            };
            opacity: {
                value: number;
            };
            scale: {
                value: number;
            };
            totalSize: {
                value: number;
            };
            uv2Transform: {
                value: {
                    applyToBufferAttribute: any;
                    applyToVector3Array: any;
                    clone: any;
                    copy: any;
                    determinant: any;
                    elements: number[];
                    equals: any;
                    extractBasis: any;
                    flattenToArrayOffset: any;
                    fromArray: any;
                    getInverse: any;
                    getNormalMatrix: any;
                    identity: any;
                    isMatrix3: boolean;
                    multiply: any;
                    multiplyMatrices: any;
                    multiplyScalar: any;
                    multiplyVector3: any;
                    multiplyVector3Array: any;
                    premultiply: any;
                    rotate: any;
                    scale: any;
                    set: any;
                    setFromMatrix4: any;
                    setUvTransform: any;
                    toArray: any;
                    translate: any;
                    transpose: any;
                    transposeIntoArray: any;
                };
            };
            uvTransform: {
                value: {
                    applyToBufferAttribute: any;
                    applyToVector3Array: any;
                    clone: any;
                    copy: any;
                    determinant: any;
                    elements: number[];
                    equals: any;
                    extractBasis: any;
                    flattenToArrayOffset: any;
                    fromArray: any;
                    getInverse: any;
                    getNormalMatrix: any;
                    identity: any;
                    isMatrix3: boolean;
                    multiply: any;
                    multiplyMatrices: any;
                    multiplyScalar: any;
                    multiplyVector3: any;
                    multiplyVector3Array: any;
                    premultiply: any;
                    rotate: any;
                    scale: any;
                    set: any;
                    setFromMatrix4: any;
                    setUvTransform: any;
                    toArray: any;
                    translate: any;
                    transpose: any;
                    transposeIntoArray: any;
                };
            };
        };
        vertexShader: string;
    };
    depth: {
        fragmentShader: string;
        uniforms: {
            alphaMap: {
                value: any;
            };
            diffuse: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            displacementBias: {
                value: number;
            };
            displacementMap: {
                value: any;
            };
            displacementScale: {
                value: number;
            };
            map: {
                value: any;
            };
            opacity: {
                value: number;
            };
            uv2Transform: {
                value: {
                    applyToBufferAttribute: any;
                    applyToVector3Array: any;
                    clone: any;
                    copy: any;
                    determinant: any;
                    elements: number[];
                    equals: any;
                    extractBasis: any;
                    flattenToArrayOffset: any;
                    fromArray: any;
                    getInverse: any;
                    getNormalMatrix: any;
                    identity: any;
                    isMatrix3: boolean;
                    multiply: any;
                    multiplyMatrices: any;
                    multiplyScalar: any;
                    multiplyVector3: any;
                    multiplyVector3Array: any;
                    premultiply: any;
                    rotate: any;
                    scale: any;
                    set: any;
                    setFromMatrix4: any;
                    setUvTransform: any;
                    toArray: any;
                    translate: any;
                    transpose: any;
                    transposeIntoArray: any;
                };
            };
            uvTransform: {
                value: {
                    applyToBufferAttribute: any;
                    applyToVector3Array: any;
                    clone: any;
                    copy: any;
                    determinant: any;
                    elements: number[];
                    equals: any;
                    extractBasis: any;
                    flattenToArrayOffset: any;
                    fromArray: any;
                    getInverse: any;
                    getNormalMatrix: any;
                    identity: any;
                    isMatrix3: boolean;
                    multiply: any;
                    multiplyMatrices: any;
                    multiplyScalar: any;
                    multiplyVector3: any;
                    multiplyVector3Array: any;
                    premultiply: any;
                    rotate: any;
                    scale: any;
                    set: any;
                    setFromMatrix4: any;
                    setUvTransform: any;
                    toArray: any;
                    translate: any;
                    transpose: any;
                    transposeIntoArray: any;
                };
            };
        };
        vertexShader: string;
    };
    distanceRGBA: {
        fragmentShader: string;
        uniforms: {
            alphaMap: {
                value: any;
            };
            diffuse: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            displacementBias: {
                value: number;
            };
            displacementMap: {
                value: any;
            };
            displacementScale: {
                value: number;
            };
            farDistance: {
                value: number;
            };
            map: {
                value: any;
            };
            nearDistance: {
                value: number;
            };
            opacity: {
                value: number;
            };
            referencePosition: {
                value: {
                    add: any;
                    addScalar: any;
                    addScaledVector: any;
                    addVectors: any;
                    angleTo: any;
                    applyAxisAngle: any;
                    applyEuler: any;
                    applyMatrix3: any;
                    applyMatrix4: any;
                    applyNormalMatrix: any;
                    applyProjection: any;
                    applyQuaternion: any;
                    ceil: any;
                    clamp: any;
                    clampLength: any;
                    clampScalar: any;
                    clone: any;
                    copy: any;
                    cross: any;
                    crossVectors: any;
                    distanceTo: any;
                    distanceToManhattan: any;
                    distanceToSquared: any;
                    divide: any;
                    divideScalar: any;
                    dot: any;
                    equals: any;
                    floor: any;
                    fromArray: any;
                    fromAttribute: any;
                    fromBufferAttribute: any;
                    getColumnFromMatrix: any;
                    getComponent: any;
                    getPositionFromMatrix: any;
                    getScaleFromMatrix: any;
                    isVector3: boolean;
                    length: any;
                    lengthManhattan: any;
                    lengthSq: any;
                    lerp: any;
                    lerpVectors: any;
                    manhattanDistanceTo: any;
                    manhattanLength: any;
                    max: any;
                    min: any;
                    multiply: any;
                    multiplyScalar: any;
                    multiplyVectors: any;
                    negate: any;
                    normalize: any;
                    project: any;
                    projectOnPlane: any;
                    projectOnVector: any;
                    random: any;
                    reflect: any;
                    round: any;
                    roundToZero: any;
                    set: any;
                    setComponent: any;
                    setEulerFromQuaternion: any;
                    setEulerFromRotationMatrix: any;
                    setFromCylindrical: any;
                    setFromCylindricalCoords: any;
                    setFromMatrix3Column: any;
                    setFromMatrixColumn: any;
                    setFromMatrixPosition: any;
                    setFromMatrixScale: any;
                    setFromSpherical: any;
                    setFromSphericalCoords: any;
                    setLength: any;
                    setScalar: any;
                    setX: any;
                    setY: any;
                    setZ: any;
                    sub: any;
                    subScalar: any;
                    subVectors: any;
                    toArray: any;
                    transformDirection: any;
                    unproject: any;
                    x: number;
                    y: number;
                    z: number;
                };
            };
            uv2Transform: {
                value: {
                    applyToBufferAttribute: any;
                    applyToVector3Array: any;
                    clone: any;
                    copy: any;
                    determinant: any;
                    elements: number[];
                    equals: any;
                    extractBasis: any;
                    flattenToArrayOffset: any;
                    fromArray: any;
                    getInverse: any;
                    getNormalMatrix: any;
                    identity: any;
                    isMatrix3: boolean;
                    multiply: any;
                    multiplyMatrices: any;
                    multiplyScalar: any;
                    multiplyVector3: any;
                    multiplyVector3Array: any;
                    premultiply: any;
                    rotate: any;
                    scale: any;
                    set: any;
                    setFromMatrix4: any;
                    setUvTransform: any;
                    toArray: any;
                    translate: any;
                    transpose: any;
                    transposeIntoArray: any;
                };
            };
            uvTransform: {
                value: {
                    applyToBufferAttribute: any;
                    applyToVector3Array: any;
                    clone: any;
                    copy: any;
                    determinant: any;
                    elements: number[];
                    equals: any;
                    extractBasis: any;
                    flattenToArrayOffset: any;
                    fromArray: any;
                    getInverse: any;
                    getNormalMatrix: any;
                    identity: any;
                    isMatrix3: boolean;
                    multiply: any;
                    multiplyMatrices: any;
                    multiplyScalar: any;
                    multiplyVector3: any;
                    multiplyVector3Array: any;
                    premultiply: any;
                    rotate: any;
                    scale: any;
                    set: any;
                    setFromMatrix4: any;
                    setUvTransform: any;
                    toArray: any;
                    translate: any;
                    transpose: any;
                    transposeIntoArray: any;
                };
            };
        };
        vertexShader: string;
    };
    equirect: {
        fragmentShader: string;
        uniforms: {
            tEquirect: {
                value: any;
            };
        };
        vertexShader: string;
    };
    lambert: {
        fragmentShader: string;
        uniforms: {
            alphaMap: {
                value: any;
            };
            ambientLightColor: {
                value: any[];
            };
            aoMap: {
                value: any;
            };
            aoMapIntensity: {
                value: number;
            };
            diffuse: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            directionalLightShadows: {
                properties: {
                    shadowBias: {
                    };
                    shadowMapSize: {
                    };
                    shadowRadius: {
                    };
                };
                value: any[];
            };
            directionalLights: {
                properties: {
                    color: {
                    };
                    direction: {
                    };
                };
                value: any[];
            };
            directionalShadowMap: {
                value: any[];
            };
            directionalShadowMatrix: {
                value: any[];
            };
            emissive: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            emissiveMap: {
                value: any;
            };
            envMap: {
                value: any;
            };
            flipEnvMap: {
                value: number;
            };
            fogColor: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            fogDensity: {
                value: number;
            };
            fogFar: {
                value: number;
            };
            fogNear: {
                value: number;
            };
            hemisphereLights: {
                properties: {
                    direction: {
                    };
                    groundColor: {
                    };
                    skyColor: {
                    };
                };
                value: any[];
            };
            lightMap: {
                value: any;
            };
            lightMapIntensity: {
                value: number;
            };
            lightProbe: {
                value: any[];
            };
            map: {
                value: any;
            };
            maxMipLevel: {
                value: number;
            };
            opacity: {
                value: number;
            };
            pointLightShadows: {
                properties: {
                    shadowBias: {
                    };
                    shadowCameraFar: {
                    };
                    shadowCameraNear: {
                    };
                    shadowMapSize: {
                    };
                    shadowRadius: {
                    };
                };
                value: any[];
            };
            pointLights: {
                properties: {
                    color: {
                    };
                    decay: {
                    };
                    distance: {
                    };
                    position: {
                    };
                };
                value: any[];
            };
            pointShadowMap: {
                value: any[];
            };
            pointShadowMatrix: {
                value: any[];
            };
            rectAreaLights: {
                properties: {
                    color: {
                    };
                    height: {
                    };
                    position: {
                    };
                    width: {
                    };
                };
                value: any[];
            };
            reflectivity: {
                value: number;
            };
            refractionRatio: {
                value: number;
            };
            specularMap: {
                value: any;
            };
            spotLightShadows: {
                properties: {
                    shadowBias: {
                    };
                    shadowMapSize: {
                    };
                    shadowRadius: {
                    };
                };
                value: any[];
            };
            spotLights: {
                properties: {
                    color: {
                    };
                    coneCos: {
                    };
                    decay: {
                    };
                    direction: {
                    };
                    distance: {
                    };
                    penumbraCos: {
                    };
                    position: {
                    };
                };
                value: any[];
            };
            spotShadowMap: {
                value: any[];
            };
            spotShadowMatrix: {
                value: any[];
            };
            uv2Transform: {
                value: {
                    applyToBufferAttribute: any;
                    applyToVector3Array: any;
                    clone: any;
                    copy: any;
                    determinant: any;
                    elements: number[];
                    equals: any;
                    extractBasis: any;
                    flattenToArrayOffset: any;
                    fromArray: any;
                    getInverse: any;
                    getNormalMatrix: any;
                    identity: any;
                    isMatrix3: boolean;
                    multiply: any;
                    multiplyMatrices: any;
                    multiplyScalar: any;
                    multiplyVector3: any;
                    multiplyVector3Array: any;
                    premultiply: any;
                    rotate: any;
                    scale: any;
                    set: any;
                    setFromMatrix4: any;
                    setUvTransform: any;
                    toArray: any;
                    translate: any;
                    transpose: any;
                    transposeIntoArray: any;
                };
            };
            uvTransform: {
                value: {
                    applyToBufferAttribute: any;
                    applyToVector3Array: any;
                    clone: any;
                    copy: any;
                    determinant: any;
                    elements: number[];
                    equals: any;
                    extractBasis: any;
                    flattenToArrayOffset: any;
                    fromArray: any;
                    getInverse: any;
                    getNormalMatrix: any;
                    identity: any;
                    isMatrix3: boolean;
                    multiply: any;
                    multiplyMatrices: any;
                    multiplyScalar: any;
                    multiplyVector3: any;
                    multiplyVector3Array: any;
                    premultiply: any;
                    rotate: any;
                    scale: any;
                    set: any;
                    setFromMatrix4: any;
                    setUvTransform: any;
                    toArray: any;
                    translate: any;
                    transpose: any;
                    transposeIntoArray: any;
                };
            };
        };
        vertexShader: string;
    };
    matcap: {
        fragmentShader: string;
        uniforms: {
            alphaMap: {
                value: any;
            };
            bumpMap: {
                value: any;
            };
            bumpScale: {
                value: number;
            };
            diffuse: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            displacementBias: {
                value: number;
            };
            displacementMap: {
                value: any;
            };
            displacementScale: {
                value: number;
            };
            fogColor: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            fogDensity: {
                value: number;
            };
            fogFar: {
                value: number;
            };
            fogNear: {
                value: number;
            };
            map: {
                value: any;
            };
            matcap: {
                value: any;
            };
            normalMap: {
                value: any;
            };
            normalScale: {
                value: {
                    add: any;
                    addScalar: any;
                    addScaledVector: any;
                    addVectors: any;
                    angle: any;
                    applyMatrix3: any;
                    ceil: any;
                    clamp: any;
                    clampLength: any;
                    clampScalar: any;
                    clone: any;
                    copy: any;
                    cross: any;
                    distanceTo: any;
                    distanceToManhattan: any;
                    distanceToSquared: any;
                    divide: any;
                    divideScalar: any;
                    dot: any;
                    equals: any;
                    floor: any;
                    fromArray: any;
                    fromAttribute: any;
                    fromBufferAttribute: any;
                    getComponent: any;
                    height: number;
                    isVector2: boolean;
                    length: any;
                    lengthManhattan: any;
                    lengthSq: any;
                    lerp: any;
                    lerpVectors: any;
                    manhattanDistanceTo: any;
                    manhattanLength: any;
                    max: any;
                    min: any;
                    multiply: any;
                    multiplyScalar: any;
                    negate: any;
                    normalize: any;
                    random: any;
                    rotateAround: any;
                    round: any;
                    roundToZero: any;
                    set: any;
                    setComponent: any;
                    setLength: any;
                    setScalar: any;
                    setX: any;
                    setY: any;
                    sub: any;
                    subScalar: any;
                    subVectors: any;
                    toArray: any;
                    width: number;
                    x: number;
                    y: number;
                };
            };
            opacity: {
                value: number;
            };
            uv2Transform: {
                value: {
                    applyToBufferAttribute: any;
                    applyToVector3Array: any;
                    clone: any;
                    copy: any;
                    determinant: any;
                    elements: number[];
                    equals: any;
                    extractBasis: any;
                    flattenToArrayOffset: any;
                    fromArray: any;
                    getInverse: any;
                    getNormalMatrix: any;
                    identity: any;
                    isMatrix3: boolean;
                    multiply: any;
                    multiplyMatrices: any;
                    multiplyScalar: any;
                    multiplyVector3: any;
                    multiplyVector3Array: any;
                    premultiply: any;
                    rotate: any;
                    scale: any;
                    set: any;
                    setFromMatrix4: any;
                    setUvTransform: any;
                    toArray: any;
                    translate: any;
                    transpose: any;
                    transposeIntoArray: any;
                };
            };
            uvTransform: {
                value: {
                    applyToBufferAttribute: any;
                    applyToVector3Array: any;
                    clone: any;
                    copy: any;
                    determinant: any;
                    elements: number[];
                    equals: any;
                    extractBasis: any;
                    flattenToArrayOffset: any;
                    fromArray: any;
                    getInverse: any;
                    getNormalMatrix: any;
                    identity: any;
                    isMatrix3: boolean;
                    multiply: any;
                    multiplyMatrices: any;
                    multiplyScalar: any;
                    multiplyVector3: any;
                    multiplyVector3Array: any;
                    premultiply: any;
                    rotate: any;
                    scale: any;
                    set: any;
                    setFromMatrix4: any;
                    setUvTransform: any;
                    toArray: any;
                    translate: any;
                    transpose: any;
                    transposeIntoArray: any;
                };
            };
        };
        vertexShader: string;
    };
    normal: {
        fragmentShader: string;
        uniforms: {
            alphaMap: {
                value: any;
            };
            bumpMap: {
                value: any;
            };
            bumpScale: {
                value: number;
            };
            diffuse: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            displacementBias: {
                value: number;
            };
            displacementMap: {
                value: any;
            };
            displacementScale: {
                value: number;
            };
            map: {
                value: any;
            };
            normalMap: {
                value: any;
            };
            normalScale: {
                value: {
                    add: any;
                    addScalar: any;
                    addScaledVector: any;
                    addVectors: any;
                    angle: any;
                    applyMatrix3: any;
                    ceil: any;
                    clamp: any;
                    clampLength: any;
                    clampScalar: any;
                    clone: any;
                    copy: any;
                    cross: any;
                    distanceTo: any;
                    distanceToManhattan: any;
                    distanceToSquared: any;
                    divide: any;
                    divideScalar: any;
                    dot: any;
                    equals: any;
                    floor: any;
                    fromArray: any;
                    fromAttribute: any;
                    fromBufferAttribute: any;
                    getComponent: any;
                    height: number;
                    isVector2: boolean;
                    length: any;
                    lengthManhattan: any;
                    lengthSq: any;
                    lerp: any;
                    lerpVectors: any;
                    manhattanDistanceTo: any;
                    manhattanLength: any;
                    max: any;
                    min: any;
                    multiply: any;
                    multiplyScalar: any;
                    negate: any;
                    normalize: any;
                    random: any;
                    rotateAround: any;
                    round: any;
                    roundToZero: any;
                    set: any;
                    setComponent: any;
                    setLength: any;
                    setScalar: any;
                    setX: any;
                    setY: any;
                    sub: any;
                    subScalar: any;
                    subVectors: any;
                    toArray: any;
                    width: number;
                    x: number;
                    y: number;
                };
            };
            opacity: {
                value: number;
            };
            uv2Transform: {
                value: {
                    applyToBufferAttribute: any;
                    applyToVector3Array: any;
                    clone: any;
                    copy: any;
                    determinant: any;
                    elements: number[];
                    equals: any;
                    extractBasis: any;
                    flattenToArrayOffset: any;
                    fromArray: any;
                    getInverse: any;
                    getNormalMatrix: any;
                    identity: any;
                    isMatrix3: boolean;
                    multiply: any;
                    multiplyMatrices: any;
                    multiplyScalar: any;
                    multiplyVector3: any;
                    multiplyVector3Array: any;
                    premultiply: any;
                    rotate: any;
                    scale: any;
                    set: any;
                    setFromMatrix4: any;
                    setUvTransform: any;
                    toArray: any;
                    translate: any;
                    transpose: any;
                    transposeIntoArray: any;
                };
            };
            uvTransform: {
                value: {
                    applyToBufferAttribute: any;
                    applyToVector3Array: any;
                    clone: any;
                    copy: any;
                    determinant: any;
                    elements: number[];
                    equals: any;
                    extractBasis: any;
                    flattenToArrayOffset: any;
                    fromArray: any;
                    getInverse: any;
                    getNormalMatrix: any;
                    identity: any;
                    isMatrix3: boolean;
                    multiply: any;
                    multiplyMatrices: any;
                    multiplyScalar: any;
                    multiplyVector3: any;
                    multiplyVector3Array: any;
                    premultiply: any;
                    rotate: any;
                    scale: any;
                    set: any;
                    setFromMatrix4: any;
                    setUvTransform: any;
                    toArray: any;
                    translate: any;
                    transpose: any;
                    transposeIntoArray: any;
                };
            };
        };
        vertexShader: string;
    };
    phong: {
        fragmentShader: string;
        uniforms: {
            alphaMap: {
                value: any;
            };
            ambientLightColor: {
                value: any[];
            };
            aoMap: {
                value: any;
            };
            aoMapIntensity: {
                value: number;
            };
            bumpMap: {
                value: any;
            };
            bumpScale: {
                value: number;
            };
            diffuse: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            directionalLightShadows: {
                properties: {
                    shadowBias: {
                    };
                    shadowMapSize: {
                    };
                    shadowRadius: {
                    };
                };
                value: any[];
            };
            directionalLights: {
                properties: {
                    color: {
                    };
                    direction: {
                    };
                };
                value: any[];
            };
            directionalShadowMap: {
                value: any[];
            };
            directionalShadowMatrix: {
                value: any[];
            };
            displacementBias: {
                value: number;
            };
            displacementMap: {
                value: any;
            };
            displacementScale: {
                value: number;
            };
            emissive: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            emissiveMap: {
                value: any;
            };
            envMap: {
                value: any;
            };
            flipEnvMap: {
                value: number;
            };
            fogColor: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            fogDensity: {
                value: number;
            };
            fogFar: {
                value: number;
            };
            fogNear: {
                value: number;
            };
            hemisphereLights: {
                properties: {
                    direction: {
                    };
                    groundColor: {
                    };
                    skyColor: {
                    };
                };
                value: any[];
            };
            lightMap: {
                value: any;
            };
            lightMapIntensity: {
                value: number;
            };
            lightProbe: {
                value: any[];
            };
            map: {
                value: any;
            };
            maxMipLevel: {
                value: number;
            };
            normalMap: {
                value: any;
            };
            normalScale: {
                value: {
                    add: any;
                    addScalar: any;
                    addScaledVector: any;
                    addVectors: any;
                    angle: any;
                    applyMatrix3: any;
                    ceil: any;
                    clamp: any;
                    clampLength: any;
                    clampScalar: any;
                    clone: any;
                    copy: any;
                    cross: any;
                    distanceTo: any;
                    distanceToManhattan: any;
                    distanceToSquared: any;
                    divide: any;
                    divideScalar: any;
                    dot: any;
                    equals: any;
                    floor: any;
                    fromArray: any;
                    fromAttribute: any;
                    fromBufferAttribute: any;
                    getComponent: any;
                    height: number;
                    isVector2: boolean;
                    length: any;
                    lengthManhattan: any;
                    lengthSq: any;
                    lerp: any;
                    lerpVectors: any;
                    manhattanDistanceTo: any;
                    manhattanLength: any;
                    max: any;
                    min: any;
                    multiply: any;
                    multiplyScalar: any;
                    negate: any;
                    normalize: any;
                    random: any;
                    rotateAround: any;
                    round: any;
                    roundToZero: any;
                    set: any;
                    setComponent: any;
                    setLength: any;
                    setScalar: any;
                    setX: any;
                    setY: any;
                    sub: any;
                    subScalar: any;
                    subVectors: any;
                    toArray: any;
                    width: number;
                    x: number;
                    y: number;
                };
            };
            opacity: {
                value: number;
            };
            pointLightShadows: {
                properties: {
                    shadowBias: {
                    };
                    shadowCameraFar: {
                    };
                    shadowCameraNear: {
                    };
                    shadowMapSize: {
                    };
                    shadowRadius: {
                    };
                };
                value: any[];
            };
            pointLights: {
                properties: {
                    color: {
                    };
                    decay: {
                    };
                    distance: {
                    };
                    position: {
                    };
                };
                value: any[];
            };
            pointShadowMap: {
                value: any[];
            };
            pointShadowMatrix: {
                value: any[];
            };
            rectAreaLights: {
                properties: {
                    color: {
                    };
                    height: {
                    };
                    position: {
                    };
                    width: {
                    };
                };
                value: any[];
            };
            reflectivity: {
                value: number;
            };
            refractionRatio: {
                value: number;
            };
            shininess: {
                value: number;
            };
            specular: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            specularMap: {
                value: any;
            };
            spotLightShadows: {
                properties: {
                    shadowBias: {
                    };
                    shadowMapSize: {
                    };
                    shadowRadius: {
                    };
                };
                value: any[];
            };
            spotLights: {
                properties: {
                    color: {
                    };
                    coneCos: {
                    };
                    decay: {
                    };
                    direction: {
                    };
                    distance: {
                    };
                    penumbraCos: {
                    };
                    position: {
                    };
                };
                value: any[];
            };
            spotShadowMap: {
                value: any[];
            };
            spotShadowMatrix: {
                value: any[];
            };
            uv2Transform: {
                value: {
                    applyToBufferAttribute: any;
                    applyToVector3Array: any;
                    clone: any;
                    copy: any;
                    determinant: any;
                    elements: number[];
                    equals: any;
                    extractBasis: any;
                    flattenToArrayOffset: any;
                    fromArray: any;
                    getInverse: any;
                    getNormalMatrix: any;
                    identity: any;
                    isMatrix3: boolean;
                    multiply: any;
                    multiplyMatrices: any;
                    multiplyScalar: any;
                    multiplyVector3: any;
                    multiplyVector3Array: any;
                    premultiply: any;
                    rotate: any;
                    scale: any;
                    set: any;
                    setFromMatrix4: any;
                    setUvTransform: any;
                    toArray: any;
                    translate: any;
                    transpose: any;
                    transposeIntoArray: any;
                };
            };
            uvTransform: {
                value: {
                    applyToBufferAttribute: any;
                    applyToVector3Array: any;
                    clone: any;
                    copy: any;
                    determinant: any;
                    elements: number[];
                    equals: any;
                    extractBasis: any;
                    flattenToArrayOffset: any;
                    fromArray: any;
                    getInverse: any;
                    getNormalMatrix: any;
                    identity: any;
                    isMatrix3: boolean;
                    multiply: any;
                    multiplyMatrices: any;
                    multiplyScalar: any;
                    multiplyVector3: any;
                    multiplyVector3Array: any;
                    premultiply: any;
                    rotate: any;
                    scale: any;
                    set: any;
                    setFromMatrix4: any;
                    setUvTransform: any;
                    toArray: any;
                    translate: any;
                    transpose: any;
                    transposeIntoArray: any;
                };
            };
        };
        vertexShader: string;
    };
    physical: {
        fragmentShader: string;
        uniforms: {
            alphaMap: {
                value: any;
            };
            ambientLightColor: {
                value: any[];
            };
            aoMap: {
                value: any;
            };
            aoMapIntensity: {
                value: number;
            };
            bumpMap: {
                value: any;
            };
            bumpScale: {
                value: number;
            };
            clearcoat: {
                value: number;
            };
            clearcoatMap: {
                value: any;
            };
            clearcoatNormalMap: {
                value: any;
            };
            clearcoatNormalScale: {
                value: {
                    add: any;
                    addScalar: any;
                    addScaledVector: any;
                    addVectors: any;
                    angle: any;
                    applyMatrix3: any;
                    ceil: any;
                    clamp: any;
                    clampLength: any;
                    clampScalar: any;
                    clone: any;
                    copy: any;
                    cross: any;
                    distanceTo: any;
                    distanceToManhattan: any;
                    distanceToSquared: any;
                    divide: any;
                    divideScalar: any;
                    dot: any;
                    equals: any;
                    floor: any;
                    fromArray: any;
                    fromAttribute: any;
                    fromBufferAttribute: any;
                    getComponent: any;
                    height: number;
                    isVector2: boolean;
                    length: any;
                    lengthManhattan: any;
                    lengthSq: any;
                    lerp: any;
                    lerpVectors: any;
                    manhattanDistanceTo: any;
                    manhattanLength: any;
                    max: any;
                    min: any;
                    multiply: any;
                    multiplyScalar: any;
                    negate: any;
                    normalize: any;
                    random: any;
                    rotateAround: any;
                    round: any;
                    roundToZero: any;
                    set: any;
                    setComponent: any;
                    setLength: any;
                    setScalar: any;
                    setX: any;
                    setY: any;
                    sub: any;
                    subScalar: any;
                    subVectors: any;
                    toArray: any;
                    width: number;
                    x: number;
                    y: number;
                };
            };
            clearcoatRoughness: {
                value: number;
            };
            clearcoatRoughnessMap: {
                value: any;
            };
            diffuse: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            directionalLightShadows: {
                properties: {
                    shadowBias: {
                    };
                    shadowMapSize: {
                    };
                    shadowRadius: {
                    };
                };
                value: any[];
            };
            directionalLights: {
                properties: {
                    color: {
                    };
                    direction: {
                    };
                };
                value: any[];
            };
            directionalShadowMap: {
                value: any[];
            };
            directionalShadowMatrix: {
                value: any[];
            };
            displacementBias: {
                value: number;
            };
            displacementMap: {
                value: any;
            };
            displacementScale: {
                value: number;
            };
            emissive: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            emissiveMap: {
                value: any;
            };
            envMap: {
                value: any;
            };
            envMapIntensity: {
                value: number;
            };
            flipEnvMap: {
                value: number;
            };
            fogColor: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            fogDensity: {
                value: number;
            };
            fogFar: {
                value: number;
            };
            fogNear: {
                value: number;
            };
            hemisphereLights: {
                properties: {
                    direction: {
                    };
                    groundColor: {
                    };
                    skyColor: {
                    };
                };
                value: any[];
            };
            lightMap: {
                value: any;
            };
            lightMapIntensity: {
                value: number;
            };
            lightProbe: {
                value: any[];
            };
            map: {
                value: any;
            };
            maxMipLevel: {
                value: number;
            };
            metalness: {
                value: number;
            };
            metalnessMap: {
                value: any;
            };
            normalMap: {
                value: any;
            };
            normalScale: {
                value: {
                    add: any;
                    addScalar: any;
                    addScaledVector: any;
                    addVectors: any;
                    angle: any;
                    applyMatrix3: any;
                    ceil: any;
                    clamp: any;
                    clampLength: any;
                    clampScalar: any;
                    clone: any;
                    copy: any;
                    cross: any;
                    distanceTo: any;
                    distanceToManhattan: any;
                    distanceToSquared: any;
                    divide: any;
                    divideScalar: any;
                    dot: any;
                    equals: any;
                    floor: any;
                    fromArray: any;
                    fromAttribute: any;
                    fromBufferAttribute: any;
                    getComponent: any;
                    height: number;
                    isVector2: boolean;
                    length: any;
                    lengthManhattan: any;
                    lengthSq: any;
                    lerp: any;
                    lerpVectors: any;
                    manhattanDistanceTo: any;
                    manhattanLength: any;
                    max: any;
                    min: any;
                    multiply: any;
                    multiplyScalar: any;
                    negate: any;
                    normalize: any;
                    random: any;
                    rotateAround: any;
                    round: any;
                    roundToZero: any;
                    set: any;
                    setComponent: any;
                    setLength: any;
                    setScalar: any;
                    setX: any;
                    setY: any;
                    sub: any;
                    subScalar: any;
                    subVectors: any;
                    toArray: any;
                    width: number;
                    x: number;
                    y: number;
                };
            };
            opacity: {
                value: number;
            };
            pointLightShadows: {
                properties: {
                    shadowBias: {
                    };
                    shadowCameraFar: {
                    };
                    shadowCameraNear: {
                    };
                    shadowMapSize: {
                    };
                    shadowRadius: {
                    };
                };
                value: any[];
            };
            pointLights: {
                properties: {
                    color: {
                    };
                    decay: {
                    };
                    distance: {
                    };
                    position: {
                    };
                };
                value: any[];
            };
            pointShadowMap: {
                value: any[];
            };
            pointShadowMatrix: {
                value: any[];
            };
            rectAreaLights: {
                properties: {
                    color: {
                    };
                    height: {
                    };
                    position: {
                    };
                    width: {
                    };
                };
                value: any[];
            };
            reflectivity: {
                value: number;
            };
            refractionRatio: {
                value: number;
            };
            roughness: {
                value: number;
            };
            roughnessMap: {
                value: any;
            };
            sheen: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            spotLightShadows: {
                properties: {
                    shadowBias: {
                    };
                    shadowMapSize: {
                    };
                    shadowRadius: {
                    };
                };
                value: any[];
            };
            spotLights: {
                properties: {
                    color: {
                    };
                    coneCos: {
                    };
                    decay: {
                    };
                    direction: {
                    };
                    distance: {
                    };
                    penumbraCos: {
                    };
                    position: {
                    };
                };
                value: any[];
            };
            spotShadowMap: {
                value: any[];
            };
            spotShadowMatrix: {
                value: any[];
            };
            transparency: {
                value: number;
            };
            uv2Transform: {
                value: {
                    applyToBufferAttribute: any;
                    applyToVector3Array: any;
                    clone: any;
                    copy: any;
                    determinant: any;
                    elements: number[];
                    equals: any;
                    extractBasis: any;
                    flattenToArrayOffset: any;
                    fromArray: any;
                    getInverse: any;
                    getNormalMatrix: any;
                    identity: any;
                    isMatrix3: boolean;
                    multiply: any;
                    multiplyMatrices: any;
                    multiplyScalar: any;
                    multiplyVector3: any;
                    multiplyVector3Array: any;
                    premultiply: any;
                    rotate: any;
                    scale: any;
                    set: any;
                    setFromMatrix4: any;
                    setUvTransform: any;
                    toArray: any;
                    translate: any;
                    transpose: any;
                    transposeIntoArray: any;
                };
            };
            uvTransform: {
                value: {
                    applyToBufferAttribute: any;
                    applyToVector3Array: any;
                    clone: any;
                    copy: any;
                    determinant: any;
                    elements: number[];
                    equals: any;
                    extractBasis: any;
                    flattenToArrayOffset: any;
                    fromArray: any;
                    getInverse: any;
                    getNormalMatrix: any;
                    identity: any;
                    isMatrix3: boolean;
                    multiply: any;
                    multiplyMatrices: any;
                    multiplyScalar: any;
                    multiplyVector3: any;
                    multiplyVector3Array: any;
                    premultiply: any;
                    rotate: any;
                    scale: any;
                    set: any;
                    setFromMatrix4: any;
                    setUvTransform: any;
                    toArray: any;
                    translate: any;
                    transpose: any;
                    transposeIntoArray: any;
                };
            };
        };
        vertexShader: string;
    };
    points: {
        fragmentShader: string;
        uniforms: {
            alphaMap: {
                value: any;
            };
            diffuse: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            fogColor: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            fogDensity: {
                value: number;
            };
            fogFar: {
                value: number;
            };
            fogNear: {
                value: number;
            };
            map: {
                value: any;
            };
            opacity: {
                value: number;
            };
            scale: {
                value: number;
            };
            size: {
                value: number;
            };
            uvTransform: {
                value: {
                    applyToBufferAttribute: any;
                    applyToVector3Array: any;
                    clone: any;
                    copy: any;
                    determinant: any;
                    elements: number[];
                    equals: any;
                    extractBasis: any;
                    flattenToArrayOffset: any;
                    fromArray: any;
                    getInverse: any;
                    getNormalMatrix: any;
                    identity: any;
                    isMatrix3: boolean;
                    multiply: any;
                    multiplyMatrices: any;
                    multiplyScalar: any;
                    multiplyVector3: any;
                    multiplyVector3Array: any;
                    premultiply: any;
                    rotate: any;
                    scale: any;
                    set: any;
                    setFromMatrix4: any;
                    setUvTransform: any;
                    toArray: any;
                    translate: any;
                    transpose: any;
                    transposeIntoArray: any;
                };
            };
        };
        vertexShader: string;
    };
    shadow: {
        fragmentShader: string;
        uniforms: {
            ambientLightColor: {
                value: any[];
            };
            color: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            directionalLightShadows: {
                properties: {
                    shadowBias: {
                    };
                    shadowMapSize: {
                    };
                    shadowRadius: {
                    };
                };
                value: any[];
            };
            directionalLights: {
                properties: {
                    color: {
                    };
                    direction: {
                    };
                };
                value: any[];
            };
            directionalShadowMap: {
                value: any[];
            };
            directionalShadowMatrix: {
                value: any[];
            };
            fogColor: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            fogDensity: {
                value: number;
            };
            fogFar: {
                value: number;
            };
            fogNear: {
                value: number;
            };
            hemisphereLights: {
                properties: {
                    direction: {
                    };
                    groundColor: {
                    };
                    skyColor: {
                    };
                };
                value: any[];
            };
            lightProbe: {
                value: any[];
            };
            opacity: {
                value: number;
            };
            pointLightShadows: {
                properties: {
                    shadowBias: {
                    };
                    shadowCameraFar: {
                    };
                    shadowCameraNear: {
                    };
                    shadowMapSize: {
                    };
                    shadowRadius: {
                    };
                };
                value: any[];
            };
            pointLights: {
                properties: {
                    color: {
                    };
                    decay: {
                    };
                    distance: {
                    };
                    position: {
                    };
                };
                value: any[];
            };
            pointShadowMap: {
                value: any[];
            };
            pointShadowMatrix: {
                value: any[];
            };
            rectAreaLights: {
                properties: {
                    color: {
                    };
                    height: {
                    };
                    position: {
                    };
                    width: {
                    };
                };
                value: any[];
            };
            spotLightShadows: {
                properties: {
                    shadowBias: {
                    };
                    shadowMapSize: {
                    };
                    shadowRadius: {
                    };
                };
                value: any[];
            };
            spotLights: {
                properties: {
                    color: {
                    };
                    coneCos: {
                    };
                    decay: {
                    };
                    direction: {
                    };
                    distance: {
                    };
                    penumbraCos: {
                    };
                    position: {
                    };
                };
                value: any[];
            };
            spotShadowMap: {
                value: any[];
            };
            spotShadowMatrix: {
                value: any[];
            };
        };
        vertexShader: string;
    };
    sprite: {
        fragmentShader: string;
        uniforms: {
            alphaMap: {
                value: any;
            };
            center: {
                value: {
                    add: any;
                    addScalar: any;
                    addScaledVector: any;
                    addVectors: any;
                    angle: any;
                    applyMatrix3: any;
                    ceil: any;
                    clamp: any;
                    clampLength: any;
                    clampScalar: any;
                    clone: any;
                    copy: any;
                    cross: any;
                    distanceTo: any;
                    distanceToManhattan: any;
                    distanceToSquared: any;
                    divide: any;
                    divideScalar: any;
                    dot: any;
                    equals: any;
                    floor: any;
                    fromArray: any;
                    fromAttribute: any;
                    fromBufferAttribute: any;
                    getComponent: any;
                    height: number;
                    isVector2: boolean;
                    length: any;
                    lengthManhattan: any;
                    lengthSq: any;
                    lerp: any;
                    lerpVectors: any;
                    manhattanDistanceTo: any;
                    manhattanLength: any;
                    max: any;
                    min: any;
                    multiply: any;
                    multiplyScalar: any;
                    negate: any;
                    normalize: any;
                    random: any;
                    rotateAround: any;
                    round: any;
                    roundToZero: any;
                    set: any;
                    setComponent: any;
                    setLength: any;
                    setScalar: any;
                    setX: any;
                    setY: any;
                    sub: any;
                    subScalar: any;
                    subVectors: any;
                    toArray: any;
                    width: number;
                    x: number;
                    y: number;
                };
            };
            diffuse: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            fogColor: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            fogDensity: {
                value: number;
            };
            fogFar: {
                value: number;
            };
            fogNear: {
                value: number;
            };
            map: {
                value: any;
            };
            opacity: {
                value: number;
            };
            rotation: {
                value: number;
            };
            uvTransform: {
                value: {
                    applyToBufferAttribute: any;
                    applyToVector3Array: any;
                    clone: any;
                    copy: any;
                    determinant: any;
                    elements: number[];
                    equals: any;
                    extractBasis: any;
                    flattenToArrayOffset: any;
                    fromArray: any;
                    getInverse: any;
                    getNormalMatrix: any;
                    identity: any;
                    isMatrix3: boolean;
                    multiply: any;
                    multiplyMatrices: any;
                    multiplyScalar: any;
                    multiplyVector3: any;
                    multiplyVector3Array: any;
                    premultiply: any;
                    rotate: any;
                    scale: any;
                    set: any;
                    setFromMatrix4: any;
                    setUvTransform: any;
                    toArray: any;
                    translate: any;
                    transpose: any;
                    transposeIntoArray: any;
                };
            };
        };
        vertexShader: string;
    };
    standard: {
        fragmentShader: string;
        uniforms: {
            alphaMap: {
                value: any;
            };
            ambientLightColor: {
                value: any[];
            };
            aoMap: {
                value: any;
            };
            aoMapIntensity: {
                value: number;
            };
            bumpMap: {
                value: any;
            };
            bumpScale: {
                value: number;
            };
            diffuse: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            directionalLightShadows: {
                properties: {
                    shadowBias: {
                    };
                    shadowMapSize: {
                    };
                    shadowRadius: {
                    };
                };
                value: any[];
            };
            directionalLights: {
                properties: {
                    color: {
                    };
                    direction: {
                    };
                };
                value: any[];
            };
            directionalShadowMap: {
                value: any[];
            };
            directionalShadowMatrix: {
                value: any[];
            };
            displacementBias: {
                value: number;
            };
            displacementMap: {
                value: any;
            };
            displacementScale: {
                value: number;
            };
            emissive: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            emissiveMap: {
                value: any;
            };
            envMap: {
                value: any;
            };
            envMapIntensity: {
                value: number;
            };
            flipEnvMap: {
                value: number;
            };
            fogColor: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            fogDensity: {
                value: number;
            };
            fogFar: {
                value: number;
            };
            fogNear: {
                value: number;
            };
            hemisphereLights: {
                properties: {
                    direction: {
                    };
                    groundColor: {
                    };
                    skyColor: {
                    };
                };
                value: any[];
            };
            lightMap: {
                value: any;
            };
            lightMapIntensity: {
                value: number;
            };
            lightProbe: {
                value: any[];
            };
            map: {
                value: any;
            };
            maxMipLevel: {
                value: number;
            };
            metalness: {
                value: number;
            };
            metalnessMap: {
                value: any;
            };
            normalMap: {
                value: any;
            };
            normalScale: {
                value: {
                    add: any;
                    addScalar: any;
                    addScaledVector: any;
                    addVectors: any;
                    angle: any;
                    applyMatrix3: any;
                    ceil: any;
                    clamp: any;
                    clampLength: any;
                    clampScalar: any;
                    clone: any;
                    copy: any;
                    cross: any;
                    distanceTo: any;
                    distanceToManhattan: any;
                    distanceToSquared: any;
                    divide: any;
                    divideScalar: any;
                    dot: any;
                    equals: any;
                    floor: any;
                    fromArray: any;
                    fromAttribute: any;
                    fromBufferAttribute: any;
                    getComponent: any;
                    height: number;
                    isVector2: boolean;
                    length: any;
                    lengthManhattan: any;
                    lengthSq: any;
                    lerp: any;
                    lerpVectors: any;
                    manhattanDistanceTo: any;
                    manhattanLength: any;
                    max: any;
                    min: any;
                    multiply: any;
                    multiplyScalar: any;
                    negate: any;
                    normalize: any;
                    random: any;
                    rotateAround: any;
                    round: any;
                    roundToZero: any;
                    set: any;
                    setComponent: any;
                    setLength: any;
                    setScalar: any;
                    setX: any;
                    setY: any;
                    sub: any;
                    subScalar: any;
                    subVectors: any;
                    toArray: any;
                    width: number;
                    x: number;
                    y: number;
                };
            };
            opacity: {
                value: number;
            };
            pointLightShadows: {
                properties: {
                    shadowBias: {
                    };
                    shadowCameraFar: {
                    };
                    shadowCameraNear: {
                    };
                    shadowMapSize: {
                    };
                    shadowRadius: {
                    };
                };
                value: any[];
            };
            pointLights: {
                properties: {
                    color: {
                    };
                    decay: {
                    };
                    distance: {
                    };
                    position: {
                    };
                };
                value: any[];
            };
            pointShadowMap: {
                value: any[];
            };
            pointShadowMatrix: {
                value: any[];
            };
            rectAreaLights: {
                properties: {
                    color: {
                    };
                    height: {
                    };
                    position: {
                    };
                    width: {
                    };
                };
                value: any[];
            };
            reflectivity: {
                value: number;
            };
            refractionRatio: {
                value: number;
            };
            roughness: {
                value: number;
            };
            roughnessMap: {
                value: any;
            };
            spotLightShadows: {
                properties: {
                    shadowBias: {
                    };
                    shadowMapSize: {
                    };
                    shadowRadius: {
                    };
                };
                value: any[];
            };
            spotLights: {
                properties: {
                    color: {
                    };
                    coneCos: {
                    };
                    decay: {
                    };
                    direction: {
                    };
                    distance: {
                    };
                    penumbraCos: {
                    };
                    position: {
                    };
                };
                value: any[];
            };
            spotShadowMap: {
                value: any[];
            };
            spotShadowMatrix: {
                value: any[];
            };
            uv2Transform: {
                value: {
                    applyToBufferAttribute: any;
                    applyToVector3Array: any;
                    clone: any;
                    copy: any;
                    determinant: any;
                    elements: number[];
                    equals: any;
                    extractBasis: any;
                    flattenToArrayOffset: any;
                    fromArray: any;
                    getInverse: any;
                    getNormalMatrix: any;
                    identity: any;
                    isMatrix3: boolean;
                    multiply: any;
                    multiplyMatrices: any;
                    multiplyScalar: any;
                    multiplyVector3: any;
                    multiplyVector3Array: any;
                    premultiply: any;
                    rotate: any;
                    scale: any;
                    set: any;
                    setFromMatrix4: any;
                    setUvTransform: any;
                    toArray: any;
                    translate: any;
                    transpose: any;
                    transposeIntoArray: any;
                };
            };
            uvTransform: {
                value: {
                    applyToBufferAttribute: any;
                    applyToVector3Array: any;
                    clone: any;
                    copy: any;
                    determinant: any;
                    elements: number[];
                    equals: any;
                    extractBasis: any;
                    flattenToArrayOffset: any;
                    fromArray: any;
                    getInverse: any;
                    getNormalMatrix: any;
                    identity: any;
                    isMatrix3: boolean;
                    multiply: any;
                    multiplyMatrices: any;
                    multiplyScalar: any;
                    multiplyVector3: any;
                    multiplyVector3Array: any;
                    premultiply: any;
                    rotate: any;
                    scale: any;
                    set: any;
                    setFromMatrix4: any;
                    setUvTransform: any;
                    toArray: any;
                    translate: any;
                    transpose: any;
                    transposeIntoArray: any;
                };
            };
        };
        vertexShader: string;
    };
    toon: {
        fragmentShader: string;
        uniforms: {
            alphaMap: {
                value: any;
            };
            ambientLightColor: {
                value: any[];
            };
            aoMap: {
                value: any;
            };
            aoMapIntensity: {
                value: number;
            };
            bumpMap: {
                value: any;
            };
            bumpScale: {
                value: number;
            };
            diffuse: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            directionalLightShadows: {
                properties: {
                    shadowBias: {
                    };
                    shadowMapSize: {
                    };
                    shadowRadius: {
                    };
                };
                value: any[];
            };
            directionalLights: {
                properties: {
                    color: {
                    };
                    direction: {
                    };
                };
                value: any[];
            };
            directionalShadowMap: {
                value: any[];
            };
            directionalShadowMatrix: {
                value: any[];
            };
            displacementBias: {
                value: number;
            };
            displacementMap: {
                value: any;
            };
            displacementScale: {
                value: number;
            };
            emissive: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            emissiveMap: {
                value: any;
            };
            fogColor: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            fogDensity: {
                value: number;
            };
            fogFar: {
                value: number;
            };
            fogNear: {
                value: number;
            };
            gradientMap: {
                value: any;
            };
            hemisphereLights: {
                properties: {
                    direction: {
                    };
                    groundColor: {
                    };
                    skyColor: {
                    };
                };
                value: any[];
            };
            lightMap: {
                value: any;
            };
            lightMapIntensity: {
                value: number;
            };
            lightProbe: {
                value: any[];
            };
            map: {
                value: any;
            };
            normalMap: {
                value: any;
            };
            normalScale: {
                value: {
                    add: any;
                    addScalar: any;
                    addScaledVector: any;
                    addVectors: any;
                    angle: any;
                    applyMatrix3: any;
                    ceil: any;
                    clamp: any;
                    clampLength: any;
                    clampScalar: any;
                    clone: any;
                    copy: any;
                    cross: any;
                    distanceTo: any;
                    distanceToManhattan: any;
                    distanceToSquared: any;
                    divide: any;
                    divideScalar: any;
                    dot: any;
                    equals: any;
                    floor: any;
                    fromArray: any;
                    fromAttribute: any;
                    fromBufferAttribute: any;
                    getComponent: any;
                    height: number;
                    isVector2: boolean;
                    length: any;
                    lengthManhattan: any;
                    lengthSq: any;
                    lerp: any;
                    lerpVectors: any;
                    manhattanDistanceTo: any;
                    manhattanLength: any;
                    max: any;
                    min: any;
                    multiply: any;
                    multiplyScalar: any;
                    negate: any;
                    normalize: any;
                    random: any;
                    rotateAround: any;
                    round: any;
                    roundToZero: any;
                    set: any;
                    setComponent: any;
                    setLength: any;
                    setScalar: any;
                    setX: any;
                    setY: any;
                    sub: any;
                    subScalar: any;
                    subVectors: any;
                    toArray: any;
                    width: number;
                    x: number;
                    y: number;
                };
            };
            opacity: {
                value: number;
            };
            pointLightShadows: {
                properties: {
                    shadowBias: {
                    };
                    shadowCameraFar: {
                    };
                    shadowCameraNear: {
                    };
                    shadowMapSize: {
                    };
                    shadowRadius: {
                    };
                };
                value: any[];
            };
            pointLights: {
                properties: {
                    color: {
                    };
                    decay: {
                    };
                    distance: {
                    };
                    position: {
                    };
                };
                value: any[];
            };
            pointShadowMap: {
                value: any[];
            };
            pointShadowMatrix: {
                value: any[];
            };
            rectAreaLights: {
                properties: {
                    color: {
                    };
                    height: {
                    };
                    position: {
                    };
                    width: {
                    };
                };
                value: any[];
            };
            shininess: {
                value: number;
            };
            specular: {
                value: {
                    add: any;
                    addColors: any;
                    addScalar: any;
                    b: number;
                    clone: any;
                    convertGammaToLinear: any;
                    convertLinearToGamma: any;
                    convertLinearToSRGB: any;
                    convertSRGBToLinear: any;
                    copy: any;
                    copyGammaToLinear: any;
                    copyLinearToGamma: any;
                    copyLinearToSRGB: any;
                    copySRGBToLinear: any;
                    equals: any;
                    fromArray: any;
                    g: number;
                    getHSL: any;
                    getHex: any;
                    getHexString: any;
                    getStyle: any;
                    isColor: boolean;
                    lerp: any;
                    lerpHSL: any;
                    multiply: any;
                    multiplyScalar: any;
                    offsetHSL: any;
                    r: number;
                    set: any;
                    setColorName: any;
                    setHSL: any;
                    setHex: any;
                    setRGB: any;
                    setScalar: any;
                    setStyle: any;
                    sub: any;
                    toArray: any;
                    toJSON: any;
                };
            };
            specularMap: {
                value: any;
            };
            spotLightShadows: {
                properties: {
                    shadowBias: {
                    };
                    shadowMapSize: {
                    };
                    shadowRadius: {
                    };
                };
                value: any[];
            };
            spotLights: {
                properties: {
                    color: {
                    };
                    coneCos: {
                    };
                    decay: {
                    };
                    direction: {
                    };
                    distance: {
                    };
                    penumbraCos: {
                    };
                    position: {
                    };
                };
                value: any[];
            };
            spotShadowMap: {
                value: any[];
            };
            spotShadowMatrix: {
                value: any[];
            };
            uv2Transform: {
                value: {
                    applyToBufferAttribute: any;
                    applyToVector3Array: any;
                    clone: any;
                    copy: any;
                    determinant: any;
                    elements: number[];
                    equals: any;
                    extractBasis: any;
                    flattenToArrayOffset: any;
                    fromArray: any;
                    getInverse: any;
                    getNormalMatrix: any;
                    identity: any;
                    isMatrix3: boolean;
                    multiply: any;
                    multiplyMatrices: any;
                    multiplyScalar: any;
                    multiplyVector3: any;
                    multiplyVector3Array: any;
                    premultiply: any;
                    rotate: any;
                    scale: any;
                    set: any;
                    setFromMatrix4: any;
                    setUvTransform: any;
                    toArray: any;
                    translate: any;
                    transpose: any;
                    transposeIntoArray: any;
                };
            };
            uvTransform: {
                value: {
                    applyToBufferAttribute: any;
                    applyToVector3Array: any;
                    clone: any;
                    copy: any;
                    determinant: any;
                    elements: number[];
                    equals: any;
                    extractBasis: any;
                    flattenToArrayOffset: any;
                    fromArray: any;
                    getInverse: any;
                    getNormalMatrix: any;
                    identity: any;
                    isMatrix3: boolean;
                    multiply: any;
                    multiplyMatrices: any;
                    multiplyScalar: any;
                    multiplyVector3: any;
                    multiplyVector3Array: any;
                    premultiply: any;
                    rotate: any;
                    scale: any;
                    set: any;
                    setFromMatrix4: any;
                    setUvTransform: any;
                    toArray: any;
                    translate: any;
                    transpose: any;
                    transposeIntoArray: any;
                };
            };
        };
        vertexShader: string;
    };
};

export const UniformsLib: {
    aomap: {
        aoMap: {
            value: any;
        };
        aoMapIntensity: {
            value: number;
        };
    };
    bumpmap: {
        bumpMap: {
            value: any;
        };
        bumpScale: {
            value: number;
        };
    };
    common: {
        alphaMap: {
            value: any;
        };
        diffuse: {
            value: {
                add: any;
                addColors: any;
                addScalar: any;
                b: number;
                clone: any;
                convertGammaToLinear: any;
                convertLinearToGamma: any;
                convertLinearToSRGB: any;
                convertSRGBToLinear: any;
                copy: any;
                copyGammaToLinear: any;
                copyLinearToGamma: any;
                copyLinearToSRGB: any;
                copySRGBToLinear: any;
                equals: any;
                fromArray: any;
                g: number;
                getHSL: any;
                getHex: any;
                getHexString: any;
                getStyle: any;
                isColor: boolean;
                lerp: any;
                lerpHSL: any;
                multiply: any;
                multiplyScalar: any;
                offsetHSL: any;
                r: number;
                set: any;
                setColorName: any;
                setHSL: any;
                setHex: any;
                setRGB: any;
                setScalar: any;
                setStyle: any;
                sub: any;
                toArray: any;
                toJSON: any;
            };
        };
        map: {
            value: any;
        };
        opacity: {
            value: number;
        };
        uv2Transform: {
            value: {
                applyToBufferAttribute: any;
                applyToVector3Array: any;
                clone: any;
                copy: any;
                determinant: any;
                elements: number[];
                equals: any;
                extractBasis: any;
                flattenToArrayOffset: any;
                fromArray: any;
                getInverse: any;
                getNormalMatrix: any;
                identity: any;
                isMatrix3: boolean;
                multiply: any;
                multiplyMatrices: any;
                multiplyScalar: any;
                multiplyVector3: any;
                multiplyVector3Array: any;
                premultiply: any;
                rotate: any;
                scale: any;
                set: any;
                setFromMatrix4: any;
                setUvTransform: any;
                toArray: any;
                translate: any;
                transpose: any;
                transposeIntoArray: any;
            };
        };
        uvTransform: {
            value: {
                applyToBufferAttribute: any;
                applyToVector3Array: any;
                clone: any;
                copy: any;
                determinant: any;
                elements: number[];
                equals: any;
                extractBasis: any;
                flattenToArrayOffset: any;
                fromArray: any;
                getInverse: any;
                getNormalMatrix: any;
                identity: any;
                isMatrix3: boolean;
                multiply: any;
                multiplyMatrices: any;
                multiplyScalar: any;
                multiplyVector3: any;
                multiplyVector3Array: any;
                premultiply: any;
                rotate: any;
                scale: any;
                set: any;
                setFromMatrix4: any;
                setUvTransform: any;
                toArray: any;
                translate: any;
                transpose: any;
                transposeIntoArray: any;
            };
        };
    };
    displacementmap: {
        displacementBias: {
            value: number;
        };
        displacementMap: {
            value: any;
        };
        displacementScale: {
            value: number;
        };
    };
    emissivemap: {
        emissiveMap: {
            value: any;
        };
    };
    envmap: {
        envMap: {
            value: any;
        };
        flipEnvMap: {
            value: number;
        };
        maxMipLevel: {
            value: number;
        };
        reflectivity: {
            value: number;
        };
        refractionRatio: {
            value: number;
        };
    };
    fog: {
        fogColor: {
            value: {
                add: any;
                addColors: any;
                addScalar: any;
                b: number;
                clone: any;
                convertGammaToLinear: any;
                convertLinearToGamma: any;
                convertLinearToSRGB: any;
                convertSRGBToLinear: any;
                copy: any;
                copyGammaToLinear: any;
                copyLinearToGamma: any;
                copyLinearToSRGB: any;
                copySRGBToLinear: any;
                equals: any;
                fromArray: any;
                g: number;
                getHSL: any;
                getHex: any;
                getHexString: any;
                getStyle: any;
                isColor: boolean;
                lerp: any;
                lerpHSL: any;
                multiply: any;
                multiplyScalar: any;
                offsetHSL: any;
                r: number;
                set: any;
                setColorName: any;
                setHSL: any;
                setHex: any;
                setRGB: any;
                setScalar: any;
                setStyle: any;
                sub: any;
                toArray: any;
                toJSON: any;
            };
        };
        fogDensity: {
            value: number;
        };
        fogFar: {
            value: number;
        };
        fogNear: {
            value: number;
        };
    };
    gradientmap: {
        gradientMap: {
            value: any;
        };
    };
    lightmap: {
        lightMap: {
            value: any;
        };
        lightMapIntensity: {
            value: number;
        };
    };
    lights: {
        ambientLightColor: {
            value: any[];
        };
        directionalLightShadows: {
            properties: {
                shadowBias: {
                };
                shadowMapSize: {
                };
                shadowRadius: {
                };
            };
            value: any[];
        };
        directionalLights: {
            properties: {
                color: {
                };
                direction: {
                };
            };
            value: any[];
        };
        directionalShadowMap: {
            value: any[];
        };
        directionalShadowMatrix: {
            value: any[];
        };
        hemisphereLights: {
            properties: {
                direction: {
                };
                groundColor: {
                };
                skyColor: {
                };
            };
            value: any[];
        };
        lightProbe: {
            value: any[];
        };
        pointLightShadows: {
            properties: {
                shadowBias: {
                };
                shadowCameraFar: {
                };
                shadowCameraNear: {
                };
                shadowMapSize: {
                };
                shadowRadius: {
                };
            };
            value: any[];
        };
        pointLights: {
            properties: {
                color: {
                };
                decay: {
                };
                distance: {
                };
                position: {
                };
            };
            value: any[];
        };
        pointShadowMap: {
            value: any[];
        };
        pointShadowMatrix: {
            value: any[];
        };
        rectAreaLights: {
            properties: {
                color: {
                };
                height: {
                };
                position: {
                };
                width: {
                };
            };
            value: any[];
        };
        spotLightShadows: {
            properties: {
                shadowBias: {
                };
                shadowMapSize: {
                };
                shadowRadius: {
                };
            };
            value: any[];
        };
        spotLights: {
            properties: {
                color: {
                };
                coneCos: {
                };
                decay: {
                };
                direction: {
                };
                distance: {
                };
                penumbraCos: {
                };
                position: {
                };
            };
            value: any[];
        };
        spotShadowMap: {
            value: any[];
        };
        spotShadowMatrix: {
            value: any[];
        };
    };
    metalnessmap: {
        metalnessMap: {
            value: any;
        };
    };
    normalmap: {
        normalMap: {
            value: any;
        };
        normalScale: {
            value: {
                add: any;
                addScalar: any;
                addScaledVector: any;
                addVectors: any;
                angle: any;
                applyMatrix3: any;
                ceil: any;
                clamp: any;
                clampLength: any;
                clampScalar: any;
                clone: any;
                copy: any;
                cross: any;
                distanceTo: any;
                distanceToManhattan: any;
                distanceToSquared: any;
                divide: any;
                divideScalar: any;
                dot: any;
                equals: any;
                floor: any;
                fromArray: any;
                fromAttribute: any;
                fromBufferAttribute: any;
                getComponent: any;
                height: number;
                isVector2: boolean;
                length: any;
                lengthManhattan: any;
                lengthSq: any;
                lerp: any;
                lerpVectors: any;
                manhattanDistanceTo: any;
                manhattanLength: any;
                max: any;
                min: any;
                multiply: any;
                multiplyScalar: any;
                negate: any;
                normalize: any;
                random: any;
                rotateAround: any;
                round: any;
                roundToZero: any;
                set: any;
                setComponent: any;
                setLength: any;
                setScalar: any;
                setX: any;
                setY: any;
                sub: any;
                subScalar: any;
                subVectors: any;
                toArray: any;
                width: number;
                x: number;
                y: number;
            };
        };
    };
    points: {
        alphaMap: {
            value: any;
        };
        diffuse: {
            value: {
                add: any;
                addColors: any;
                addScalar: any;
                b: number;
                clone: any;
                convertGammaToLinear: any;
                convertLinearToGamma: any;
                convertLinearToSRGB: any;
                convertSRGBToLinear: any;
                copy: any;
                copyGammaToLinear: any;
                copyLinearToGamma: any;
                copyLinearToSRGB: any;
                copySRGBToLinear: any;
                equals: any;
                fromArray: any;
                g: number;
                getHSL: any;
                getHex: any;
                getHexString: any;
                getStyle: any;
                isColor: boolean;
                lerp: any;
                lerpHSL: any;
                multiply: any;
                multiplyScalar: any;
                offsetHSL: any;
                r: number;
                set: any;
                setColorName: any;
                setHSL: any;
                setHex: any;
                setRGB: any;
                setScalar: any;
                setStyle: any;
                sub: any;
                toArray: any;
                toJSON: any;
            };
        };
        map: {
            value: any;
        };
        opacity: {
            value: number;
        };
        scale: {
            value: number;
        };
        size: {
            value: number;
        };
        uvTransform: {
            value: {
                applyToBufferAttribute: any;
                applyToVector3Array: any;
                clone: any;
                copy: any;
                determinant: any;
                elements: number[];
                equals: any;
                extractBasis: any;
                flattenToArrayOffset: any;
                fromArray: any;
                getInverse: any;
                getNormalMatrix: any;
                identity: any;
                isMatrix3: boolean;
                multiply: any;
                multiplyMatrices: any;
                multiplyScalar: any;
                multiplyVector3: any;
                multiplyVector3Array: any;
                premultiply: any;
                rotate: any;
                scale: any;
                set: any;
                setFromMatrix4: any;
                setUvTransform: any;
                toArray: any;
                translate: any;
                transpose: any;
                transposeIntoArray: any;
            };
        };
    };
    roughnessmap: {
        roughnessMap: {
            value: any;
        };
    };
    specularmap: {
        specularMap: {
            value: any;
        };
    };
    sprite: {
        alphaMap: {
            value: any;
        };
        center: {
            value: {
                add: any;
                addScalar: any;
                addScaledVector: any;
                addVectors: any;
                angle: any;
                applyMatrix3: any;
                ceil: any;
                clamp: any;
                clampLength: any;
                clampScalar: any;
                clone: any;
                copy: any;
                cross: any;
                distanceTo: any;
                distanceToManhattan: any;
                distanceToSquared: any;
                divide: any;
                divideScalar: any;
                dot: any;
                equals: any;
                floor: any;
                fromArray: any;
                fromAttribute: any;
                fromBufferAttribute: any;
                getComponent: any;
                height: number;
                isVector2: boolean;
                length: any;
                lengthManhattan: any;
                lengthSq: any;
                lerp: any;
                lerpVectors: any;
                manhattanDistanceTo: any;
                manhattanLength: any;
                max: any;
                min: any;
                multiply: any;
                multiplyScalar: any;
                negate: any;
                normalize: any;
                random: any;
                rotateAround: any;
                round: any;
                roundToZero: any;
                set: any;
                setComponent: any;
                setLength: any;
                setScalar: any;
                setX: any;
                setY: any;
                sub: any;
                subScalar: any;
                subVectors: any;
                toArray: any;
                width: number;
                x: number;
                y: number;
            };
        };
        diffuse: {
            value: {
                add: any;
                addColors: any;
                addScalar: any;
                b: number;
                clone: any;
                convertGammaToLinear: any;
                convertLinearToGamma: any;
                convertLinearToSRGB: any;
                convertSRGBToLinear: any;
                copy: any;
                copyGammaToLinear: any;
                copyLinearToGamma: any;
                copyLinearToSRGB: any;
                copySRGBToLinear: any;
                equals: any;
                fromArray: any;
                g: number;
                getHSL: any;
                getHex: any;
                getHexString: any;
                getStyle: any;
                isColor: boolean;
                lerp: any;
                lerpHSL: any;
                multiply: any;
                multiplyScalar: any;
                offsetHSL: any;
                r: number;
                set: any;
                setColorName: any;
                setHSL: any;
                setHex: any;
                setRGB: any;
                setScalar: any;
                setStyle: any;
                sub: any;
                toArray: any;
                toJSON: any;
            };
        };
        map: {
            value: any;
        };
        opacity: {
            value: number;
        };
        rotation: {
            value: number;
        };
        uvTransform: {
            value: {
                applyToBufferAttribute: any;
                applyToVector3Array: any;
                clone: any;
                copy: any;
                determinant: any;
                elements: number[];
                equals: any;
                extractBasis: any;
                flattenToArrayOffset: any;
                fromArray: any;
                getInverse: any;
                getNormalMatrix: any;
                identity: any;
                isMatrix3: boolean;
                multiply: any;
                multiplyMatrices: any;
                multiplyScalar: any;
                multiplyVector3: any;
                multiplyVector3Array: any;
                premultiply: any;
                rotate: any;
                scale: any;
                set: any;
                setFromMatrix4: any;
                setUvTransform: any;
                toArray: any;
                translate: any;
                transpose: any;
                transposeIntoArray: any;
            };
        };
    };
};

export const VertexColors: number;

export function AxesHelper(size: any): void;

export function AxisHelper(size: any): any;

export function BinaryTextureLoader(manager: any): any;

export function BoundingBoxHelper(object: any, color: any): any;

export class BoxBufferGeometry extends BufferGeometry {

	constructor(
		width?: number,
		height?: number,
		depth?: number,
		widthSegments?: number,
		heightSegments?: number,
		depthSegments?: number
	);

	parameters: {
		width: number;
		height: number;
		depth: number;
		widthSegments: number;
		heightSegments: number;
		depthSegments: number;
	};

}

/**
 * BoxGeometry is the quadrilateral primitive geometry class. It is typically used for creating a cube or irregular quadrilateral of the dimensions provided within the (optional) 'width', 'height', & 'depth' constructor arguments.
 */
export class BoxGeometry extends Geometry {

	/**
	 * @param width â€” Width of the sides on the X axis.
	 * @param height â€” Height of the sides on the Y axis.
	 * @param depth â€” Depth of the sides on the Z axis.
	 * @param widthSegments â€” Number of segmented faces along the width of the sides.
	 * @param heightSegments â€” Number of segmented faces along the height of the sides.
	 * @param depthSegments â€” Number of segmented faces along the depth of the sides.
	 */
	constructor(
		width?: number,
		height?: number,
		depth?: number,
		widthSegments?: number,
		heightSegments?: number,
		depthSegments?: number
	);

	parameters: {
		width: number;
		height: number;
		depth: number;
		widthSegments: number;
		heightSegments: number;
		depthSegments: number;
	};

}


export function CanvasRenderer(): void;

export function CircleBufferGeometry(radius: any, segments: any, thetaStart: any, thetaLength: any): void;

export function CircleGeometry(radius: any, segments: any, thetaStart: any, thetaLength: any): void;

export function ClosedSplineCurve3(points: any): void;

export function ConeBufferGeometry(radius: any, height: any, radialSegments: any, heightSegments: any, openEnded: any, thetaStart: any, thetaLength: any): void;

export function ConeGeometry(radius: any, height: any, radialSegments: any, heightSegments: any, openEnded: any, thetaStart: any, thetaLength: any): void;

export function CubeGeometry(width: any, height: any, depth: any, widthSegments: any, heightSegments: any, depthSegments: any): void;

export function CylinderBufferGeometry(radiusTop: any, radiusBottom: any, height: any, radialSegments: any, heightSegments: any, openEnded: any, thetaStart: any, thetaLength: any): void;

export function CylinderGeometry(radiusTop: any, radiusBottom: any, height: any, radialSegments: any, heightSegments: any, openEnded: any, thetaStart: any, thetaLength: any): void;

export function DodecahedronBufferGeometry(radius: any, detail: any): void;

export function DodecahedronGeometry(radius: any, detail: any): void;

export function DynamicBufferAttribute(array: any, itemSize: any): any;

export function EdgesGeometry(geometry: any, thresholdAngle: any): void;

export function EdgesHelper(object: any, hex: any): any;

export function Face4(a: any, b: any, c: any, d: any, normal: any, color: any, materialIndex: any): any;

export function Float32Attribute(array: any, itemSize: any): any;

export function Float32BufferAttribute(array: any, itemSize: any, normalized: any): void;

export function Float64Attribute(array: any, itemSize: any): any;

export function Float64BufferAttribute(array: any, itemSize: any, normalized: any): void;

export function IcosahedronBufferGeometry(radius: any, detail: any): void;

export function IcosahedronGeometry(radius: any, detail: any): void;

export function Int16Attribute(array: any, itemSize: any): any;

export function Int16BufferAttribute(array: any, itemSize: any, normalized: any): void;

export function Int32Attribute(array: any, itemSize: any): any;

export function Int32BufferAttribute(array: any, itemSize: any, normalized: any): void;

export function Int8Attribute(array: any, itemSize: any): any;

export function Int8BufferAttribute(array: any, itemSize: any, normalized: any): void;

export function JSONLoader(): void;

export function LatheBufferGeometry(points: any, segments: any, phiStart: any, phiLength: any): void;

export function LatheGeometry(points: any, segments: any, phiStart: any, phiLength: any): void;

export function LensFlare(): void;

export function MeshFaceMaterial(materials: any): any;

export function MultiMaterial(materials: any): any;

export function OctahedronBufferGeometry(radius: any, detail: any): void;

export function OctahedronGeometry(radius: any, detail: any): void;

export function ParametricBufferGeometry(func: any, slices: any, stacks: any): void;

export function ParametricGeometry(func: any, slices: any, stacks: any): void;

export function Particle(material: any): any;

export function ParticleBasicMaterial(parameters: any): any;

export function ParticleSystem(geometry: any, material: any): any;

export function ParticleSystemMaterial(parameters: any): any;

export function PointCloud(geometry: any, material: any): any;

export function PointCloudMaterial(parameters: any): any;

export function PolarGridHelper(radius: any, radials: any, circles: any, divisions: any, color1: any, color2: any): void;

export function PolyhedronBufferGeometry(vertices: any, indices: any, radius: any, detail: any): any;

export function PolyhedronGeometry(vertices: any, indices: any, radius: any, detail: any): void;

export function RingBufferGeometry(innerRadius: any, outerRadius: any, thetaSegments: any, phiSegments: any, thetaStart: any, thetaLength: any): void;

export function RingGeometry(innerRadius: any, outerRadius: any, thetaSegments: any, phiSegments: any, thetaStart: any, thetaLength: any): void;

export class SphereBufferGeometry extends BufferGeometry {

	constructor(
		radius?: number,
		widthSegments?: number,
		heightSegments?: number,
		phiStart?: number,
		phiLength?: number,
		thetaStart?: number,
		thetaLength?: number
	);

	parameters: {
		radius: number;
		widthSegments: number;
		heightSegments: number;
		phiStart: number;
		phiLength: number;
		thetaStart: number;
		thetaLength: number;
	};

}

/**
 * A class for generating sphere geometries
 */
export class SphereGeometry extends Geometry {

	/**
	 * The geometry is created by sweeping and calculating vertexes around the Y axis (horizontal sweep) and the Z axis (vertical sweep). Thus, incomplete spheres (akin to 'sphere slices') can be created through the use of different values of phiStart, phiLength, thetaStart and thetaLength, in order to define the points in which we start (or end) calculating those vertices.
	 *
	 * @param radius â€” sphere radius. Default is 50.
	 * @param widthSegments â€” number of horizontal segments. Minimum value is 3, and the default is 8.
	 * @param heightSegments â€” number of vertical segments. Minimum value is 2, and the default is 6.
	 * @param phiStart â€” specify horizontal starting angle. Default is 0.
	 * @param phiLength â€” specify horizontal sweep angle size. Default is Math.PI * 2.
	 * @param thetaStart â€” specify vertical starting angle. Default is 0.
	 * @param thetaLength â€” specify vertical sweep angle size. Default is Math.PI.
	 */
	constructor(
		radius?: number,
		widthSegments?: number,
		heightSegments?: number,
		phiStart?: number,
		phiLength?: number,
		thetaStart?: number,
		thetaLength?: number
	);

	parameters: {
		radius: number;
		widthSegments: number;
		heightSegments: number;
		phiStart: number;
		phiLength: number;
		thetaStart: number;
		thetaLength: number;
	};

}

export function SplineCurve3(points: any): void;

export function TetrahedronBufferGeometry(radius: any, detail: any): void;

export function TetrahedronGeometry(radius: any, detail: any): void;

export function TextBufferGeometry(text: any, parameters: any): any;

export function TextGeometry(text: any, parameters: any): void;

export function TorusBufferGeometry(radius: any, tube: any, radialSegments: any, tubularSegments: any, arc: any): void;

export function TorusGeometry(radius: any, tube: any, radialSegments: any, tubularSegments: any, arc: any): void;

export function TorusKnotBufferGeometry(radius: any, tube: any, tubularSegments: any, radialSegments: any, p: any, q: any): void;

export function TorusKnotGeometry(radius: any, tube: any, tubularSegments: any, radialSegments: any, p: any, q: any, heightScale: any): void;

export function TubeGeometry(path: any, tubularSegments: any, radius: any, radialSegments: any, closed: any, taper: any): void;

export function Uint16Attribute(array: any, itemSize: any): any;

export function Uint16BufferAttribute(array: any, itemSize: any, normalized: any): void;

export function Uint32Attribute(array: any, itemSize: any): any;

export function Uint32BufferAttribute(array: any, itemSize: any, normalized: any): void;

export function Uint8Attribute(array: any, itemSize: any): any;

export function Uint8BufferAttribute(array: any, itemSize: any, normalized: any): void;

export function Uint8ClampedAttribute(array: any, itemSize: any): any;

export function Uint8ClampedBufferAttribute(array: any, itemSize: any, normalized: any): void;

export function Vertex(x: any, y: any, z: any): any;

export function WebGLRenderTargetCube(width: any, height: any, options: any): any;

export function WebGLUtils(gl: any, extensions: any, capabilities: any): any;

export function WireframeGeometry(geometry: any): void;

export function WireframeHelper(object: any, hex: any): any;

export function XHRLoader(manager: any): any;

export namespace AnimationUtils {
    function arraySlice(array: any, from: any, to: any): any;

    function convertArray(array: any, type: any, forceClone: any): any;

    function flattenJSON(jsonKeys: any, times: any, values: any, valuePropertyName: any): void;

    function getKeyframeOrder(times: any): any;

    function isTypedArray(object: any): any;

    function makeClipAdditive(targetClip: any, referenceFrame: any, referenceClip: any, fps: any): any;

    function sortedArray(values: any, stride: any, order: any): any;

    function subclip(sourceClip: any, name: any, startFrame: any, endFrame: any, fps: any): any;

}

export namespace AudioContext {
    function getContext(): any;

    function setContext(value: any): void;

}

export namespace Cache {
    const enabled: boolean;

    const files: {
    };

    function add(key: any, file: any): void;

    function clear(): void;

    function get(key: any): any;

    function remove(key: any): void;

}

export namespace GeometryUtils {
    function center(geometry: any): any;

    function merge(geometry1: any, geometry2: any, materialIndexOffset: any): void;

}

export namespace ImageUtils {
    const crossOrigin: any;

    function getDataURL(image: any): any;

    function loadCompressedTexture(): void;

    function loadCompressedTextureCube(): void;

    function loadTexture(url: any, mapping: any, onLoad: any, onError: any): any;

    function loadTextureCube(urls: any, mapping: any, onLoad: any, onError: any): any;

}

export namespace Loader {
    namespace Handlers {
        function add(): void;

        function get(): void;

    }

}

export namespace LoaderUtils {
    function decodeText(array: any): any;

    function extractUrlBase(url: any): any;

}

export namespace Math {
    const DEG2RAD: number;

    const RAD2DEG: number;

    function ceilPowerOfTwo(value: any): any;

    function clamp(value: any, min: any, max: any): any;

    function degToRad(degrees: any): any;

    function euclideanModulo(n: any, m: any): any;

    function floorPowerOfTwo(value: any): any;

    function generateUUID(): any;

    function isPowerOfTwo(value: any): any;

    function lerp(x: any, y: any, t: any): any;

    function mapLinear(x: any, a1: any, a2: any, b1: any, b2: any): any;

    function nearestPowerOfTwo(value: any): any;

    function nextPowerOfTwo(value: any): any;

    function radToDeg(radians: any): any;

    function randFloat(low: any, high: any): any;

    function randFloatSpread(range: any): any;

    function randInt(low: any, high: any): any;

    function random16(): any;

    function setQuaternionFromProperEuler(q: any, a: any, b: any, c: any, order: any): void;

    function smootherstep(x: any, min: any, max: any): any;

    function smoothstep(x: any, min: any, max: any): any;

}

export namespace MathUtils {
    const DEG2RAD: number;

    const RAD2DEG: number;

    function ceilPowerOfTwo(value: any): any;

    function clamp(value: any, min: any, max: any): any;

    function degToRad(degrees: any): any;

    function euclideanModulo(n: any, m: any): any;

    function floorPowerOfTwo(value: any): any;

    function generateUUID(): any;

    function isPowerOfTwo(value: any): any;

    function lerp(x: any, y: any, t: any): any;

    function mapLinear(x: any, a1: any, a2: any, b1: any, b2: any): any;

    function nearestPowerOfTwo(value: any): any;

    function nextPowerOfTwo(value: any): any;

    function radToDeg(radians: any): any;

    function randFloat(low: any, high: any): any;

    function randFloatSpread(range: any): any;

    function randInt(low: any, high: any): any;

    function random16(): any;

    function setQuaternionFromProperEuler(q: any, a: any, b: any, c: any, order: any): void;

    function smootherstep(x: any, min: any, max: any): any;

    function smoothstep(x: any, min: any, max: any): any;

}

export namespace PropertyBinding {
    class Composite {
        constructor(targetGroup: any, path: any, optionalParsedPath: any);

        bind(): void;

        getValue(array: any, offset: any): void;

        setValue(array: any, offset: any): void;

        unbind(): void;

    }

}

export namespace SceneUtils {
    function attach(): void;

    function createMultiMaterialObject(): void;

    function detach(): void;

}

export namespace ShapeUtils {
    function area(contour: any): any;

    function isClockWise(pts: any): any;

    function triangulateShape(contour: any, holes: any): any;

}

export namespace UniformsUtils {
    function clone(src: any): any;

    function merge(uniforms: any): any;

}

export as namespace THREE;
